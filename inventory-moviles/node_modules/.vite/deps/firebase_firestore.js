import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-F23VYAAP.js";
import "./chunk-RSJERJUL.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var x2 = "9.6.9";
var N2 = new Logger("@firebase/firestore");
function k2() {
  return N2.logLevel;
}
function M2(t2) {
  N2.setLogLevel(t2);
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B2);
    N2.debug(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(B2);
    N2.error(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(B2);
    N2.warn(`Firestore (${x2}): ${t2}`, ...n);
  }
}
function B2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${x2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw $(e), new Error(e);
}
function q2(t2, e) {
  t2 || L2();
}
function U2(t2, e) {
  t2 || L2();
}
function K2(t2, e) {
  return t2;
}
var G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      O2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (O2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (O2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (q2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return q2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e) {
    const n = (t3) => {
      t3.error != null && O2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.p;
      return this.p = t3.token, O2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      O2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s(t3) : O2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (q2(typeof t3.token == "string"), this.p = t3.token, new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var et = class {
  getToken() {
    return Promise.resolve(new Z2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
var nt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.I(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  I(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function st(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
nt.A = -1;
var it = class {
  static R() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = st(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function rt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function ot(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function at(t2) {
  return t2 + "\0";
}
var ut = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q2(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return ut.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return ut.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new ut(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? rt(this.nanoseconds, t2.nanoseconds) : rt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new ut(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ht(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var dt = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return dt.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof dt ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var _t = class extends dt {
  construct(t2, e, n) {
    return new _t(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new _t(e);
  }
  static emptyPath() {
    return new _t([]);
  }
};
var wt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var mt = class extends dt {
  construct(t2, e, n) {
    return new mt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return wt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), mt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new mt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new Q2(G.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new Q2(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new Q2(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q2(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new mt(e);
  }
  static emptyPath() {
    return new mt([]);
  }
};
var gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(mt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return ot(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function yt() {
  return typeof atob != "undefined";
}
var pt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new pt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new pt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return rt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
pt.EMPTY_BYTE_STRING = new pt("");
var It = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Tt(t2) {
  if (q2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = It.exec(t2);
    if (q2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Et(t2.seconds),
    nanos: Et(t2.nanos)
  };
}
function Et(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function At(t2) {
  return typeof t2 == "string" ? pt.fromBase64String(t2) : pt.fromUint8Array(t2);
}
function Rt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function bt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Rt(e) ? bt(e) : e;
}
function Pt(t2) {
  const e = Tt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new ut(e.seconds, e.nanos);
}
var Vt = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = a;
  }
};
var vt = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new vt("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof vt && t2.projectId === this.projectId && t2.database === this.database;
  }
};
function St(t2) {
  return t2 == null;
}
function Dt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Ct(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Dt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var xt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new xt(_t.fromString(t2));
  }
  static fromName(t2) {
    return new xt(_t.fromString(t2).popFirst(5));
  }
  static empty() {
    return new xt(_t.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return t2 !== null && _t.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return _t.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new xt(new _t(t2.slice()));
  }
};
var Nt = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var kt = {
  nullValue: "NULL_VALUE"
};
function Mt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Rt(t2) ? 4 : Ht(t2) ? 9 : 10 : L2();
}
function Ot(t2, e) {
  if (t2 === e)
    return true;
  const n = Mt(t2);
  if (n !== Mt(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Pt(t2).isEqual(Pt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Tt(t3.timestampValue), s = Tt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return At(t3.bytesValue).isEqual(At(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Et(t3.geoPointValue.latitude) === Et(e2.geoPointValue.latitude) && Et(t3.geoPointValue.longitude) === Et(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Et(t3.integerValue) === Et(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Et(t3.doubleValue), s = Et(e2.doubleValue);
          return n2 === s ? Dt(n2) === Dt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return ot(t2.arrayValue.values || [], e.arrayValue.values || [], Ot);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ht(n2) !== ht(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Ot(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function $t(t2, e) {
  return (t2.values || []).find((t3) => Ot(t3, e)) !== void 0;
}
function Ft(t2, e) {
  if (t2 === e)
    return 0;
  const n = Mt(t2), s = Mt(e);
  if (n !== s)
    return rt(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return rt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Et(t3.integerValue || t3.doubleValue), s2 = Et(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Bt(t2.timestampValue, e.timestampValue);
    case 4:
      return Bt(Pt(t2), Pt(e));
    case 5:
      return rt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = At(t3), s2 = At(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = rt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = rt(Et(t3.latitude), Et(e2.latitude));
        if (n2 !== 0)
          return n2;
        return rt(Et(t3.longitude), Et(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = Ft(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = rt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = Ft(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return rt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function Bt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return rt(t2, e);
  const n = Tt(t2), s = Tt(e), i = rt(n.seconds, s.seconds);
  return i !== 0 ? i : rt(n.nanos, s.nanos);
}
function Lt(t2) {
  return qt(t2);
}
function qt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Tt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? At(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, xt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += qt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${qt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function Ut(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function Kt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Gt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Qt(t2) {
  return !!t2 && "nullValue" in t2;
}
function jt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Wt(t2) {
  return !!t2 && "mapValue" in t2;
}
function zt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = zt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = zt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function Ht(t2) {
  return (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
}
function Jt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || Ft(t2, e) > 0 ? t2 : e;
}
function Yt(t2, e) {
  return t2 === void 0 ? e : e === void 0 || Ft(t2, e) < 0 ? t2 : e;
}
var Xt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Xt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Wt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = zt(e);
  }
  setAll(t2) {
    let e = mt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = zt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Wt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Ot(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Wt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Xt(zt(this.value));
  }
};
function Zt(t2) {
  const e = [];
  return lt(t2.fields, (t3, n) => {
    const s = new mt([t3]);
    if (Wt(n)) {
      const t4 = Zt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new gt(e);
}
var te = class {
  constructor(t2, e, n, s, i, r) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t2) {
    return new te(t2, 0, ct.min(), ct.min(), Xt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new te(t2, 1, e, ct.min(), n, 0);
  }
  static newNoDocument(t2, e) {
    return new te(t2, 2, e, ct.min(), Xt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new te(t2, 3, e, ct.min(), Xt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Xt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Xt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof te && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new te(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var ee = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function ne(t2) {
  return t2.fields.find((t3) => t3.kind === 2);
}
function se(t2) {
  return t2.fields.filter((t3) => t3.kind !== 2);
}
ee.UNKNOWN_ID = -1;
var ie = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
var re = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new re(0, oe.min());
  }
};
var oe = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new oe(ct.min(), xt.empty(), -1);
  }
};
var ae = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.P = null;
  }
};
function ue(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new ae(t2, e, n, s, i, r, o);
}
function ce(t2) {
  const e = K2(t2);
  if (e.P === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => {
      return (e2 = t4).field.canonicalString() + e2.op.toString() + Lt(e2.value);
      var e2;
    }).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), St(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => Lt(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => Lt(t4)).join(",")), e.P = t3;
  }
  return e.P;
}
function he(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Lt(e2.value)}`;
    var e2;
  }).join(", ")}]`), St(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: ", e += t2.startAt.inclusive ? "b:" : "a:", e += t2.startAt.position.map((t3) => Lt(t3)).join(",")), t2.endAt && (e += ", endAt: ", e += t2.endAt.inclusive ? "a:" : "b:", e += t2.endAt.position.map((t3) => Lt(t3)).join(",")), `Target(${e})`;
}
function le(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!be(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Ot(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!Ve(t2.startAt, e.startAt) && Ve(t2.endAt, e.endAt)));
}
function fe(t2) {
  return xt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
function de(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof _e && t3.field.isEqual(e));
}
var _e = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.V(t2, e, n) : new we(t2, e, n) : e === "array-contains" ? new pe(t2, n) : e === "in" ? new Ie(t2, n) : e === "not-in" ? new Te(t2, n) : e === "array-contains-any" ? new Ee(t2, n) : new _e(t2, e, n);
  }
  static V(t2, e, n) {
    return e === "in" ? new me(t2, n) : new ge(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.v(Ft(e, this.value)) : e !== null && Mt(this.value) === Mt(e) && this.v(Ft(e, this.value));
  }
  v(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  S() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var we = class extends _e {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = xt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = xt.comparator(t2.key, this.key);
    return this.v(e);
  }
};
var me = class extends _e {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = ye("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var ge = class extends _e {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = ye("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function ye(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => xt.fromName(t3.referenceValue));
}
var pe = class extends _e {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Gt(e) && $t(e.arrayValue, this.value);
  }
};
var Ie = class extends _e {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && $t(this.value.arrayValue, e);
  }
};
var Te = class extends _e {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if ($t(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !$t(this.value.arrayValue, e);
  }
};
var Ee = class extends _e {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Gt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => $t(this.value.arrayValue, t3));
  }
};
var Ae = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
var Re = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function be(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function Pe(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = xt.comparator(xt.fromName(o.referenceValue), n.key);
    else {
      s = Ft(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return s;
}
function Ve(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Ot(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var ve = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, a = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = a, this.D = null, this.C = null, this.startAt, this.endAt;
  }
};
function Se(t2, e, n, s, i, r, o, a) {
  return new ve(t2, e, n, s, i, r, o, a);
}
function De(t2) {
  return new ve(t2);
}
function Ce(t2) {
  return !St(t2.limit) && t2.limitType === "F";
}
function xe(t2) {
  return !St(t2.limit) && t2.limitType === "L";
}
function Ne(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function ke(t2) {
  for (const e of t2.filters)
    if (e.S())
      return e.field;
  return null;
}
function Me(t2) {
  return t2.collectionGroup !== null;
}
function Oe(t2) {
  const e = K2(t2);
  if (e.D === null) {
    e.D = [];
    const t3 = ke(e), n = Ne(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.D.push(new Re(t3)), e.D.push(new Re(mt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.D.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.D.push(new Re(mt.keyField(), t5));
      }
    }
  }
  return e.D;
}
function $e(t2) {
  const e = K2(t2);
  if (!e.C)
    if (e.limitType === "F")
      e.C = ue(e.path, e.collectionGroup, Oe(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Oe(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new Re(n2.field, e2));
      }
      const n = e.endAt ? new Ae(e.endAt.position, !e.endAt.inclusive) : null, s = e.startAt ? new Ae(e.startAt.position, !e.startAt.inclusive) : null;
      e.C = ue(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.C;
}
function Fe(t2, e, n) {
  return new ve(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Be(t2, e) {
  return le($e(t2), $e(e)) && t2.limitType === e.limitType;
}
function Le(t2) {
  return `${ce($e(t2))}|lt:${t2.limitType}`;
}
function qe(t2) {
  return `Query(target=${he($e(t2))}; limitType=${t2.limitType})`;
}
function Ue(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : xt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = Pe(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, Oe(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = Pe(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, Oe(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function Ke(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Oe(t2)) {
      const t3 = Ge(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Ge(t2, e, n) {
  const s = t2.field.isKeyField() ? xt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? Ft(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function Qe(t2, e) {
  if (t2.N) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Dt(e) ? "-0" : e
  };
}
function je(t2) {
  return {
    integerValue: "" + t2
  };
}
function We(t2, e) {
  return Ct(e) ? je(e) : Qe(t2, e);
}
var ze = class {
  constructor() {
    this._ = void 0;
  }
};
function He(t2, e, n) {
  return t2 instanceof Xe ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Ze ? tn(t2, e) : t2 instanceof en ? nn(t2, e) : function(t3, e2) {
    const n2 = Ye(t3, e2), s = rn(n2) + rn(t3.k);
    return Kt(n2) && Kt(t3.k) ? je(s) : Qe(t3.M, s);
  }(t2, e);
}
function Je(t2, e, n) {
  return t2 instanceof Ze ? tn(t2, e) : t2 instanceof en ? nn(t2, e) : n;
}
function Ye(t2, e) {
  return t2 instanceof sn ? Kt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Xe = class extends ze {
};
var Ze = class extends ze {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function tn(t2, e) {
  const n = on(e);
  for (const e2 of t2.elements)
    n.some((t3) => Ot(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var en = class extends ze {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function nn(t2, e) {
  let n = on(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Ot(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var sn = class extends ze {
  constructor(t2, e) {
    super(), this.M = t2, this.k = e;
  }
};
function rn(t2) {
  return Et(t2.integerValue || t2.doubleValue);
}
function on(t2) {
  return Gt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var an = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function un(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Ze && e2 instanceof Ze || t3 instanceof en && e2 instanceof en ? ot(t3.elements, e2.elements, Ot) : t3 instanceof sn && e2 instanceof sn ? Ot(t3.k, e2.k) : t3 instanceof Xe && e2 instanceof Xe;
  }(t2.transform, e.transform);
}
var cn = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var hn = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new hn();
  }
  static exists(t2) {
    return new hn(void 0, t2);
  }
  static updateTime(t2) {
    return new hn(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function ln(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var fn = class {
};
function dn(t2, e, n) {
  t2 instanceof yn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = Tn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof pn ? function(t3, e2, n2) {
    if (!ln(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = Tn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(In(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function _n(t2, e, n) {
  t2 instanceof yn ? function(t3, e2, n2) {
    if (!ln(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = En(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(gn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof pn ? function(t3, e2, n2) {
    if (!ln(t3.precondition, e2))
      return;
    const s = En(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(In(t3)), i.setAll(s), e2.convertToFoundDocument(gn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    ln(t3.precondition, e2) && e2.convertToNoDocument(ct.min());
  }(t2, e);
}
function wn(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Ye(s.transform, t3 || null);
    i != null && (n == null && (n = Xt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function mn(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && ot(t3, e2, (t4, e3) => un(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function gn(t2) {
  return t2.isFoundDocument() ? t2.version : ct.min();
}
var yn = class extends fn {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var pn = class extends fn {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function In(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function Tn(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  q2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, a = e.data.field(r.field);
    s.set(r.field, Je(o, a, n[i]));
  }
  return s;
}
function En(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, He(t3, r, e));
  }
  return s;
}
var An = class extends fn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var Rn = class extends fn {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var bn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var Pn;
var Vn;
function vn(t2) {
  switch (t2) {
    default:
      return L2();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function Sn(t2) {
  if (t2 === void 0)
    return $("GRPC error has no .code"), G.UNKNOWN;
  switch (t2) {
    case Pn.OK:
      return G.OK;
    case Pn.CANCELLED:
      return G.CANCELLED;
    case Pn.UNKNOWN:
      return G.UNKNOWN;
    case Pn.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case Pn.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case Pn.INTERNAL:
      return G.INTERNAL;
    case Pn.UNAVAILABLE:
      return G.UNAVAILABLE;
    case Pn.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case Pn.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case Pn.NOT_FOUND:
      return G.NOT_FOUND;
    case Pn.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case Pn.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case Pn.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case Pn.ABORTED:
      return G.ABORTED;
    case Pn.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case Pn.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case Pn.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L2();
  }
}
(Vn = Pn || (Pn = {}))[Vn.OK = 0] = "OK", Vn[Vn.CANCELLED = 1] = "CANCELLED", Vn[Vn.UNKNOWN = 2] = "UNKNOWN", Vn[Vn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Vn[Vn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Vn[Vn.NOT_FOUND = 5] = "NOT_FOUND", Vn[Vn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Vn[Vn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Vn[Vn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Vn[Vn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Vn[Vn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Vn[Vn.ABORTED = 10] = "ABORTED", Vn[Vn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Vn[Vn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Vn[Vn.INTERNAL = 13] = "INTERNAL", Vn[Vn.UNAVAILABLE = 14] = "UNAVAILABLE", Vn[Vn.DATA_LOSS = 15] = "DATA_LOSS";
var Dn = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s === void 0)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ft(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var Cn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Nn.EMPTY;
  }
  insert(t2, e) {
    return new Cn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Nn.BLACK, null, null));
  }
  remove(t2) {
    return new Cn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Nn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new xn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new xn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new xn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new xn(this.root, t2, this.comparator, true);
  }
};
var xn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Nn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Nn.RED, this.left = s != null ? s : Nn.EMPTY, this.right = i != null ? i : Nn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Nn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Nn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Nn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Nn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Nn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Nn.EMPTY = null, Nn.RED = true, Nn.BLACK = false;
Nn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Nn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var kn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new Cn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Mn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new Mn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof kn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new kn(this.comparator);
    return e.data = t2, e;
  }
};
var Mn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function On(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var $n = new Cn(xt.comparator);
function Fn() {
  return $n;
}
var Bn = new Cn(xt.comparator);
function Ln() {
  return Bn;
}
function qn() {
  return new Dn((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var Un = new Cn(xt.comparator);
var Kn = new kn(xt.comparator);
function Gn(...t2) {
  let e = Kn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Qn = new kn(rt);
function jn() {
  return Qn;
}
var Wn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t2, zn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Wn(ct.min(), n, jn(), Fn(), Gn());
  }
};
var zn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new zn(pt.EMPTY_BYTE_STRING, e, Gn(), Gn(), Gn());
  }
};
var Hn = class {
  constructor(t2, e, n, s) {
    this.O = t2, this.removedTargetIds = e, this.key = n, this.$ = s;
  }
};
var Jn = class {
  constructor(t2, e) {
    this.targetId = t2, this.F = e;
  }
};
var Yn = class {
  constructor(t2, e, n = pt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var Xn = class {
  constructor() {
    this.B = 0, this.L = es(), this.q = pt.EMPTY_BYTE_STRING, this.U = false, this.K = true;
  }
  get current() {
    return this.U;
  }
  get resumeToken() {
    return this.q;
  }
  get G() {
    return this.B !== 0;
  }
  get j() {
    return this.K;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.K = true, this.q = t2);
  }
  H() {
    let t2 = Gn(), e = Gn(), n = Gn();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new zn(this.q, this.U, t2, e, n);
  }
  J() {
    this.K = false, this.L = es();
  }
  Y(t2, e) {
    this.K = true, this.L = this.L.insert(t2, e);
  }
  X(t2) {
    this.K = true, this.L = this.L.remove(t2);
  }
  Z() {
    this.B += 1;
  }
  tt() {
    this.B -= 1;
  }
  et() {
    this.K = true, this.U = true;
  }
};
var Zn = class {
  constructor(t2) {
    this.nt = t2, this.st = /* @__PURE__ */ new Map(), this.it = Fn(), this.rt = ts(), this.ot = new kn(rt);
  }
  at(t2) {
    for (const e of t2.O)
      t2.$ && t2.$.isFoundDocument() ? this.ut(e, t2.$) : this.ct(e, t2.key, t2.$);
    for (const e of t2.removedTargetIds)
      this.ct(e, t2.key, t2.$);
  }
  ht(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.lt(e);
      switch (t2.state) {
        case 0:
          this.ft(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.tt(), n.G || n.J(), n.W(t2.resumeToken);
          break;
        case 2:
          n.tt(), n.G || this.removeTarget(e);
          break;
        case 3:
          this.ft(e) && (n.et(), n.W(t2.resumeToken));
          break;
        case 4:
          this.ft(e) && (this.dt(e), n.W(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.st.forEach((t3, n) => {
      this.ft(n) && e(n);
    });
  }
  _t(t2) {
    const e = t2.targetId, n = t2.F.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (fe(t3))
        if (n === 0) {
          const n2 = new xt(t3.path);
          this.ct(e, n2, te.newNoDocument(n2, ct.min()));
        } else
          q2(n === 1);
      else {
        this.gt(e) !== n && (this.dt(e), this.ot = this.ot.add(e));
      }
    }
  }
  yt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.st.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && fe(i.target)) {
          const e2 = new xt(i.target.path);
          this.it.get(e2) !== null || this.It(s2, e2) || this.ct(s2, e2, te.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.H()), n2.J());
      }
    });
    let n = Gn();
    this.rt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.it.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new Wn(t2, e, this.ot, this.it, n);
    return this.it = Fn(), this.rt = ts(), this.ot = new kn(rt), s;
  }
  ut(t2, e) {
    if (!this.ft(t2))
      return;
    const n = this.It(t2, e.key) ? 2 : 0;
    this.lt(t2).Y(e.key, n), this.it = this.it.insert(e.key, e), this.rt = this.rt.insert(e.key, this.Tt(e.key).add(t2));
  }
  ct(t2, e, n) {
    if (!this.ft(t2))
      return;
    const s = this.lt(t2);
    this.It(t2, e) ? s.Y(e, 1) : s.X(e), this.rt = this.rt.insert(e, this.Tt(e).delete(t2)), n && (this.it = this.it.insert(e, n));
  }
  removeTarget(t2) {
    this.st.delete(t2);
  }
  gt(t2) {
    const e = this.lt(t2).H();
    return this.nt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Z(t2) {
    this.lt(t2).Z();
  }
  lt(t2) {
    let e = this.st.get(t2);
    return e || (e = new Xn(), this.st.set(t2, e)), e;
  }
  Tt(t2) {
    let e = this.rt.get(t2);
    return e || (e = new kn(rt), this.rt = this.rt.insert(t2, e)), e;
  }
  ft(t2) {
    const e = this.wt(t2) !== null;
    return e || O2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.st.get(t2);
    return e && e.G ? null : this.nt.Et(t2);
  }
  dt(t2) {
    this.st.set(t2, new Xn());
    this.nt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.ct(t2, e, null);
    });
  }
  It(t2, e) {
    return this.nt.getRemoteKeysForTarget(t2).has(e);
  }
};
function ts() {
  return new Cn(xt.comparator);
}
function es() {
  return new Cn(xt.comparator);
}
var ns = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var ss = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var is = class {
  constructor(t2, e) {
    this.databaseId = t2, this.N = e;
  }
};
function rs(t2, e) {
  if (t2.N) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function os(t2, e) {
  return t2.N ? e.toBase64() : e.toUint8Array();
}
function as(t2, e) {
  return rs(t2, e.toTimestamp());
}
function us(t2) {
  return q2(!!t2), ct.fromTimestamp(function(t3) {
    const e = Tt(t3);
    return new ut(e.seconds, e.nanos);
  }(t2));
}
function cs(t2, e) {
  return function(t3) {
    return new _t(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function hs(t2) {
  const e = _t.fromString(t2);
  return q2(Os(e)), e;
}
function ls(t2, e) {
  return cs(t2.databaseId, e.path);
}
function fs(t2, e) {
  const n = hs(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new Q2(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new xt(ms(n));
}
function ds(t2, e) {
  return cs(t2.databaseId, e);
}
function _s(t2) {
  const e = hs(t2);
  return e.length === 4 ? _t.emptyPath() : ms(e);
}
function ws(t2) {
  return new _t(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function ms(t2) {
  return q2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function gs(t2, e, n) {
  return {
    name: ls(t2, e),
    fields: n.value.mapValue.fields
  };
}
function ys(t2, e, n) {
  const s = fs(t2, e.name), i = us(e.updateTime), r = new Xt({
    mapValue: {
      fields: e.fields
    }
  }), o = te.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function ps(t2, e) {
  return "found" in e ? function(t3, e2) {
    q2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = fs(t3, e2.found.name), s = us(e2.found.updateTime), i = new Xt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return te.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    q2(!!e2.missing), q2(!!e2.readTime);
    const n = fs(t3, e2.missing), s = us(e2.readTime);
    return te.newNoDocument(n, s);
  }(t2, e) : L2();
}
function Is(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.N ? (q2(e2 === void 0 || typeof e2 == "string"), pt.fromBase64String(e2 || "")) : (q2(e2 === void 0 || e2 instanceof Uint8Array), pt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(t3) {
      const e2 = t3.code === void 0 ? G.UNKNOWN : Sn(t3.code);
      return new Q2(e2, t3.message || "");
    }(o);
    n = new Yn(s, i, r, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = fs(t2, s.document.name), r = us(s.document.updateTime), o = new Xt({
      mapValue: {
        fields: s.document.fields
      }
    }), a = te.newFoundDocument(i, r, o), u = s.targetIds || [], c = s.removedTargetIds || [];
    n = new Hn(u, c, a.key, a);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = fs(t2, s.document), r = s.readTime ? us(s.readTime) : ct.min(), o = te.newNoDocument(i, r), a = s.removedTargetIds || [];
    n = new Hn([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = fs(t2, s.document), r = s.removedTargetIds || [];
    n = new Hn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new bn(s), r = t3.targetId;
      n = new Jn(r, i);
    }
  }
  return n;
}
function Ts(t2, e) {
  let n;
  if (e instanceof yn)
    n = {
      update: gs(t2, e.key, e.value)
    };
  else if (e instanceof An)
    n = {
      delete: ls(t2, e.key)
    };
  else if (e instanceof pn)
    n = {
      update: gs(t2, e.key, e.data),
      updateMask: Ms(e.fieldMask)
    };
  else {
    if (!(e instanceof Rn))
      return L2();
    n = {
      verify: ls(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Xe)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Ze)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof en)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof sn)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.k
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: as(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function Es(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? hn.updateTime(us(t3.updateTime)) : t3.exists !== void 0 ? hn.exists(t3.exists) : hn.none();
  }(e.currentDocument) : hn.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      q2(e3.setToServerValue === "REQUEST_TIME"), n2 = new Xe();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Ze(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new en(t4);
    } else
      "increment" in e3 ? n2 = new sn(t3, e3.increment) : L2();
    const s2 = mt.fromServerFormat(e3.fieldPath);
    return new an(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = fs(t2, e.update.name), r = new Xt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new gt(e2.map((t5) => mt.fromServerFormat(t5)));
      }(e.updateMask);
      return new pn(i, r, t3, n, s);
    }
    return new yn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = fs(t2, e.delete);
    return new An(s2, n);
  }
  if (e.verify) {
    const s2 = fs(t2, e.verify);
    return new Rn(s2, n);
  }
  return L2();
}
function As(t2, e) {
  return t2 && t2.length > 0 ? (q2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? us(t4.updateTime) : us(e2);
    return n.isEqual(ct.min()) && (n = us(e2)), new cn(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function Rs(t2, e) {
  return {
    documents: [ds(t2, e.path)]
  };
}
function bs(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = ds(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = ds(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Cs(t5.field),
              op: "IS_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Cs(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (jt(t5.value))
          return {
            unaryFilter: {
              field: Cs(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Qt(t5.value))
          return {
            unaryFilter: {
              field: Cs(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Cs(t5.field),
          op: Ds(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Cs(t5.field),
        direction: Ss(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.N || St(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var a;
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (a = e.startAt).inclusive,
    values: a.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function Ps(t2) {
  let e = _s(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    q2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = vs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new Re(xs(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let a = null;
  n.limit && (a = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, St(e2) ? null : e2;
  }(n.limit));
  let u = null;
  n.startAt && (u = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new Ae(n2, e2);
  }(n.startAt));
  let c = null;
  return n.endAt && (c = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new Ae(n2, e2);
  }(n.endAt)), Se(e, i, o, r, a, "F", u, c);
}
function Vs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function vs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ks(t2)] : t2.fieldFilter !== void 0 ? [Ns(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => vs(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function Ss(t2) {
  return ns[t2];
}
function Ds(t2) {
  return ss[t2];
}
function Cs(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function xs(t2) {
  return mt.fromServerFormat(t2.fieldPath);
}
function Ns(t2) {
  return _e.create(xs(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ks(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = xs(t2.unaryFilter.field);
      return _e.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = xs(t2.unaryFilter.field);
      return _e.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = xs(t2.unaryFilter.field);
      return _e.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = xs(t2.unaryFilter.field);
      return _e.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function Ms(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Os(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function $s(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Bs(e)), e = Fs(t2.get(n), e);
  return Bs(e);
}
function Fs(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Bs(t2) {
  return t2 + "";
}
function Ls(t2) {
  const e = t2.length;
  if (q2(e >= 2), e === 2)
    return q2(t2.charAt(0) === "" && t2.charAt(1) === ""), _t.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new _t(s);
}
var qs = ["userId", "batchId"];
function Us(t2, e) {
  return [t2, $s(e)];
}
function Ks(t2, e, n) {
  return [t2, $s(e), n];
}
var Gs = {};
var Qs = ["parentPath", "readTime"];
var js = ["canonicalId", "targetId"];
var Ws = ["targetId", "path"];
var zs = ["path", "targetId"];
var Hs = ["collectionId", "parent"];
var Js = ["indexId", "uid"];
var Ys = ["uid", "sequenceNumber"];
var Xs = ["indexId", "uid", "arrayValue", "directionalValue", "documentKey"];
var Zs = ["indexId", "uid", "documentKey"];
var ti = ["userId", "collectionPath", "documentId"];
var ei = ["userId", "collectionPath", "largestBatchId"];
var ni = ["userId", "collectionGroup", "largestBatchId"];
var si = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var ii = [...si, "documentOverlays"];
var ri = [...ii, "indexConfiguration", "indexState", "indexEntries"];
var oi = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var ai = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var ui = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new ui((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof ui ? e : ui.resolve(e);
    } catch (t3) {
      return ui.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : ui.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : ui.reject(e);
  }
  static resolve(t2) {
    return new ui((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new ui((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new ui((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = ui.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? ui.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var ci = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.At = new j(), this.transaction.oncomplete = () => {
      this.At.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.At.reject(new fi(t2, e.error)) : this.At.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = gi(e2.target.error);
      this.At.reject(new fi(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new ci(e, t2.transaction(s, n));
    } catch (t3) {
      throw new fi(e, t3);
    }
  }
  get Rt() {
    return this.At.promise;
  }
  abort(t2) {
    t2 && this.At.reject(t2), this.aborted || (O2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  bt() {
    const t2 = this.transaction;
    this.aborted || typeof t2.commit != "function" || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new _i(e);
  }
};
var hi = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.Pt = n;
    hi.Vt(getUA()) === 12.2 && $("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return O2("SimpleDb", "Removing database:", t2), wi(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static vt() {
    if (!isIndexedDBAvailable())
      return false;
    if (hi.St())
      return true;
    const t2 = getUA(), e = hi.Vt(t2), n = 0 < e && e < 10, s = hi.Dt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static St() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Ct) === "YES";
  }
  static xt(t2, e) {
    return t2.store(e);
  }
  static Vt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Dt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Nt(t2) {
    return this.db || (O2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new fi(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new Q2(G.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new Q2(G.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new fi(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        O2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.Pt.kt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          O2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Mt && (this.db.onversionchange = (t3) => this.Mt(t3)), this.db;
  }
  Ot(t2) {
    this.Mt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Nt(t2);
        const e2 = ci.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.bt(), t3)).catch((t3) => (e2.abort(t3), ui.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.Rt, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (O2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var li = class {
  constructor(t2) {
    this.$t = t2, this.Ft = false, this.Bt = null;
  }
  get isDone() {
    return this.Ft;
  }
  get Lt() {
    return this.Bt;
  }
  set cursor(t2) {
    this.$t = t2;
  }
  done() {
    this.Ft = true;
  }
  qt(t2) {
    this.Bt = t2;
  }
  delete() {
    return wi(this.$t.delete());
  }
};
var fi = class extends Q2 {
  constructor(t2, e) {
    super(G.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function di(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var _i = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (O2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (O2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), wi(n);
  }
  add(t2) {
    O2("SimpleDb", "ADD", this.store.name, t2, t2);
    return wi(this.store.add(t2));
  }
  get(t2) {
    return wi(this.store.get(t2)).next((e) => (e === void 0 && (e = null), O2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    O2("SimpleDb", "DELETE", this.store.name, t2);
    return wi(this.store.delete(t2));
  }
  count() {
    O2("SimpleDb", "COUNT", this.store.name);
    return wi(this.store.count());
  }
  Ut(t2, e) {
    const n = this.options(t2, e);
    if (n.index || typeof this.store.getAll != "function") {
      const t3 = this.cursor(n), e2 = [];
      return this.Kt(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new ui((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  Gt(t2, e) {
    const n = this.store.getAll(t2, e === null ? void 0 : e);
    return new ui((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  Qt(t2, e) {
    O2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.jt = false;
    const s = this.cursor(n);
    return this.Kt(s, (t3, e2, n2) => n2.delete());
  }
  Wt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Kt(s, e);
  }
  zt(t2) {
    const e = this.cursor({});
    return new ui((n, s) => {
      e.onerror = (t3) => {
        const e2 = gi(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Kt(t2, e) {
    const n = [];
    return new ui((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new li(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof ui) {
          const t4 = o.catch((t5) => (r.done(), ui.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Lt === null ? i2.continue() : i2.continue(r.Lt);
      };
    }).next(() => ui.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.jt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function wi(t2) {
  return new ui((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = gi(t3.target.error);
      n(e2);
    };
  });
}
var mi = false;
function gi(t2) {
  const e = hi.Vt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new Q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return mi || (mi = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var yi = class extends ai {
  constructor(t2, e) {
    super(), this.Ht = t2, this.currentSequenceNumber = e;
  }
};
function pi(t2, e) {
  const n = K2(t2);
  return hi.xt(n.Ht, e);
}
var Ii = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        dn(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && _n(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && _n(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(ct.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Gn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && ot(this.mutations, t2.mutations, (t3, e) => mn(t3, e)) && ot(this.baseMutations, t2.baseMutations, (t3, e) => mn(t3, e));
  }
};
var Ti = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    q2(t2.mutations.length === n.length);
    let s = Un;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new Ti(t2, e, n, s);
  }
};
var Ei = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return t2 !== null && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Ai = class {
  constructor(t2, e, n, s, i = ct.min(), r = ct.min(), o = pt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new Ai(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new Ai(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Ai(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var Ri = class {
  constructor(t2) {
    this.Jt = t2;
  }
};
function bi(t2, e) {
  let n;
  if (e.document)
    n = ys(t2.Jt, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = xt.fromSegments(e.noDocument.path), s = Di(e.noDocument.readTime);
    n = te.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L2();
    {
      const t3 = xt.fromSegments(e.unknownDocument.path), s = Di(e.unknownDocument.version);
      n = te.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(vi(e.readTime)), n;
}
function Pi(t2, e) {
  const n = e.key.path.popLast().toArray(), s = Vi(e.readTime);
  if (e.isFoundDocument()) {
    const i = function(t3, e2) {
      return {
        name: ls(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: rs(t3, e2.version.toTimestamp())
      };
    }(t2.Jt, e);
    return {
      document: i,
      hasCommittedMutations: e.hasCommittedMutations,
      readTime: s,
      parentPath: n
    };
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), i = e.hasCommittedMutations;
    return {
      noDocument: {
        path: t3,
        readTime: Si(e.version)
      },
      hasCommittedMutations: i,
      readTime: s,
      parentPath: n
    };
  }
  if (e.isUnknownDocument()) {
    return {
      unknownDocument: {
        path: e.key.path.toArray(),
        version: Si(e.version)
      },
      hasCommittedMutations: true,
      readTime: s,
      parentPath: n
    };
  }
  return L2();
}
function Vi(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function vi(t2) {
  const e = new ut(t2[0], t2[1]);
  return ct.fromTimestamp(e);
}
function Si(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function Di(t2) {
  const e = new ut(t2.seconds, t2.nanoseconds);
  return ct.fromTimestamp(e);
}
function Ci(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Es(t2.Jt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Es(t2.Jt, e2)), i = ut.fromMillis(e.localWriteTimeMs);
  return new Ii(e.batchId, i, n, s);
}
function xi(t2) {
  const e = Di(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? Di(t2.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (q2((i = t2.query).documents.length === 1), s = $e(De(_s(i.documents[0])))) : s = function(t3) {
    return $e(Ps(t3));
  }(t2.query), new Ai(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, pt.fromBase64String(t2.resumeToken));
}
function Ni(t2, e) {
  const n = Si(e.snapshotVersion), s = Si(e.lastLimboFreeSnapshotVersion);
  let i;
  i = fe(e.target) ? Rs(t2.Jt, e.target) : bs(t2.Jt, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: ce(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function ki(t2) {
  const e = Ps({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Fe(e, e.limit, "L") : e;
}
function Mi(t2, e) {
  return new Ei(e.largestBatchId, Es(t2.Jt, e.overlayMutation));
}
function Oi(t2, e) {
  const n = e.path.lastSegment();
  return [t2, $s(e.path.popLast()), n];
}
var $i = class {
  getBundleMetadata(t2, e) {
    return Fi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: Di(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return Fi(t2).put({
      bundleId: (n = e).id,
      createTime: Si(us(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Bi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: ki(e2.bundledQuery),
          readTime: Di(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Bi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: Si(us(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function Fi(t2) {
  return pi(t2, "bundles");
}
function Bi(t2) {
  return pi(t2, "namedQueries");
}
var Li = class {
  constructor(t2, e) {
    this.M = t2, this.userId = e;
  }
  static Yt(t2, e) {
    const n = e.uid || "";
    return new Li(t2, n);
  }
  getOverlay(t2, e) {
    return qi(t2).get(Oi(this.userId, e)).next((t3) => t3 ? Mi(this.M, t3) : null);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Ei(e, i);
      s.push(this.Xt(t2, r));
    }), ui.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add($s(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(qi(t2).Qt("collectionPathOverlayIndex", s2));
    }), ui.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = qn(), i = $s(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return qi(t2).Ut("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = Mi(this.M, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = qn();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return qi(t2).Wt({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = Mi(this.M, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  Xt(t2, e) {
    return qi(t2).put(function(t3, e2, n) {
      const [s, i, r] = Oi(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: Ts(t3.Jt, n.mutation)
      };
    }(this.M, this.userId, e));
  }
};
function qi(t2) {
  return pi(t2, "documentOverlays");
}
var Ui = class {
  constructor() {
  }
  Zt(t2, e) {
    this.te(t2, e), e.ee();
  }
  te(t2, e) {
    if ("nullValue" in t2)
      this.ne(e, 5);
    else if ("booleanValue" in t2)
      this.ne(e, 10), e.se(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ne(e, 15), e.se(Et(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Et(t2.doubleValue);
      isNaN(n) ? this.ne(e, 13) : (this.ne(e, 15), Dt(n) ? e.se(0) : e.se(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ne(e, 20), typeof n == "string" ? e.ie(n) : (e.ie(`${n.seconds || ""}`), e.se(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.re(t2.stringValue, e), this.oe(e);
    else if ("bytesValue" in t2)
      this.ne(e, 30), e.ae(At(t2.bytesValue)), this.oe(e);
    else if ("referenceValue" in t2)
      this.ue(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ne(e, 45), e.se(n.latitude || 0), e.se(n.longitude || 0);
    } else
      "mapValue" in t2 ? Ht(t2) ? this.ne(e, Number.MAX_SAFE_INTEGER) : (this.ce(t2.mapValue, e), this.oe(e)) : "arrayValue" in t2 ? (this.he(t2.arrayValue, e), this.oe(e)) : L2();
  }
  re(t2, e) {
    this.ne(e, 25), this.le(t2, e);
  }
  le(t2, e) {
    e.ie(t2);
  }
  ce(t2, e) {
    const n = t2.fields || {};
    this.ne(e, 55);
    for (const t3 of Object.keys(n))
      this.re(t3, e), this.te(n[t3], e);
  }
  he(t2, e) {
    const n = t2.values || [];
    this.ne(e, 50);
    for (const t3 of n)
      this.te(t3, e);
  }
  ue(t2, e) {
    this.ne(e, 37);
    xt.fromName(t2).path.forEach((t3) => {
      this.ne(e, 60), this.le(t3, e);
    });
  }
  ne(t2, e) {
    t2.se(e);
  }
  oe(t2) {
    t2.se(2);
  }
};
Ui.fe = new Ui();
function Ki(t2) {
  if (t2 === 0)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function Gi(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = Ki(255 & t3[n]);
      if (e2 += s, s !== 8)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var Qi = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  de(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this._e(n.value), n = e.next();
    this.we();
  }
  me(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.ge(n.value), n = e.next();
    this.ye();
  }
  pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this._e(t3);
      else if (t3 < 2048)
        this._e(960 | t3 >>> 6), this._e(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this._e(480 | t3 >>> 12), this._e(128 | 63 & t3 >>> 6), this._e(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this._e(240 | t4 >>> 18), this._e(128 | 63 & t4 >>> 12), this._e(128 | 63 & t4 >>> 6), this._e(128 | 63 & t4);
      }
    }
    this.we();
  }
  Ie(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.ge(t3);
      else if (t3 < 2048)
        this.ge(960 | t3 >>> 6), this.ge(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.ge(480 | t3 >>> 12), this.ge(128 | 63 & t3 >>> 6), this.ge(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.ge(240 | t4 >>> 18), this.ge(128 | 63 & t4 >>> 12), this.ge(128 | 63 & t4 >>> 6), this.ge(128 | 63 & t4);
      }
    }
    this.ye();
  }
  Te(t2) {
    const e = this.Ee(t2), n = Gi(e);
    this.Ae(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Re(t2) {
    const e = this.Ee(t2), n = Gi(e);
    this.Ae(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  be() {
    this.Pe(255), this.Pe(255);
  }
  Ve() {
    this.ve(255), this.ve(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.Ae(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  Se() {
    return this.buffer.slice(0, this.position);
  }
  Ee(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = (128 & e[0]) != 0;
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  _e(t2) {
    const e = 255 & t2;
    e === 0 ? (this.Pe(0), this.Pe(255)) : e === 255 ? (this.Pe(255), this.Pe(0)) : this.Pe(e);
  }
  ge(t2) {
    const e = 255 & t2;
    e === 0 ? (this.ve(0), this.ve(255)) : e === 255 ? (this.ve(255), this.ve(0)) : this.ve(t2);
  }
  we() {
    this.Pe(0), this.Pe(1);
  }
  ye() {
    this.ve(0), this.ve(1);
  }
  Pe(t2) {
    this.Ae(1), this.buffer[this.position++] = t2;
  }
  ve(t2) {
    this.Ae(1), this.buffer[this.position++] = ~t2;
  }
  Ae(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var ji = class {
  constructor(t2) {
    this.De = t2;
  }
  ae(t2) {
    this.De.de(t2);
  }
  ie(t2) {
    this.De.pe(t2);
  }
  se(t2) {
    this.De.Te(t2);
  }
  ee() {
    this.De.be();
  }
};
var Wi = class {
  constructor(t2) {
    this.De = t2;
  }
  ae(t2) {
    this.De.me(t2);
  }
  ie(t2) {
    this.De.Ie(t2);
  }
  se(t2) {
    this.De.Re(t2);
  }
  ee() {
    this.De.Ve();
  }
};
var zi = class {
  constructor() {
    this.De = new Qi(), this.Ce = new ji(this.De), this.xe = new Wi(this.De);
  }
  seed(t2) {
    this.De.seed(t2);
  }
  Ne(t2) {
    return t2 === 0 ? this.Ce : this.xe;
  }
  Se() {
    return this.De.Se();
  }
  reset() {
    this.De.reset();
  }
};
var Hi = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  ke() {
    const t2 = this.directionalValue.length, e = t2 === 0 || this.directionalValue[t2 - 1] === 255 ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new Hi(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function Ji(t2, e) {
  let n = t2.indexId - e.indexId;
  return n !== 0 ? n : (n = Yi(t2.arrayValue, e.arrayValue), n !== 0 ? n : (n = Yi(t2.directionalValue, e.directionalValue), n !== 0 ? n : xt.comparator(t2.documentKey, e.documentKey)));
}
function Yi(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (s !== 0)
      return s;
  }
  return t2.length - e.length;
}
var Xi = class {
  constructor(t2) {
    this.collectionId = t2.collectionGroup != null ? t2.collectionGroup : t2.path.lastSegment(), this.Me = t2.orderBy, this.Oe = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.S() ? this.$e = t3 : this.Oe.push(t3);
    }
  }
  Fe(t2) {
    const e = ne(t2);
    if (e !== void 0 && !this.Be(e))
      return false;
    const n = se(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.Be(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (this.$e !== void 0) {
      const t3 = n[s];
      if (!this.Le(this.$e, t3) || !this.qe(this.Me[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Me.length || !this.qe(this.Me[i++], t3))
        return false;
    }
    return true;
  }
  Be(t2) {
    for (const e of this.Oe)
      if (this.Le(e, t2))
        return true;
    return false;
  }
  Le(t2, e) {
    if (t2 === void 0 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = t2.op === "array-contains" || t2.op === "array-contains-any";
    return e.kind === 2 === n;
  }
  qe(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (e.kind === 0 && t2.dir === "asc" || e.kind === 1 && t2.dir === "desc");
  }
};
var Zi = class {
  constructor() {
    this.Ue = new tr();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Ue.add(e), ui.resolve();
  }
  getCollectionParents(t2, e) {
    return ui.resolve(this.Ue.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return ui.resolve();
  }
  deleteFieldIndex(t2, e) {
    return ui.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return ui.resolve(null);
  }
  getFieldIndex(t2, e) {
    return ui.resolve(null);
  }
  getFieldIndexes(t2, e) {
    return ui.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return ui.resolve(null);
  }
  updateCollectionGroup(t2, e, n) {
    return ui.resolve();
  }
  updateIndexEntries(t2, e) {
    return ui.resolve();
  }
};
var tr = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new kn(_t.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new kn(_t.comparator)).toArray();
  }
};
var er = new Uint8Array(0);
var nr = class {
  constructor(t2) {
    this.user = t2, this.Ke = new tr(), this.Ge = new Dn((t3) => ce(t3), (t3, e) => le(t3, e)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ke.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ke.add(e);
      });
      const i = {
        collectionId: n,
        parent: $s(s)
      };
      return sr(t2).put(i);
    }
    return ui.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [at(e), ""], false, true);
    return sr(t2).Ut(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Ls(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = rr(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    return delete s.indexId, n.add(s).next();
  }
  deleteFieldIndex(t2, e) {
    const n = rr(t2), s = or(t2), i = ir(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = ir(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return ui.forEach(this.Qe(e), (e2) => this.getFieldIndex(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = Gn();
        return ui.forEach(i, (s2, i2) => {
          var r;
          O2("IndexedDbIndexManager", `Using index ${r = s2, `id=${r.indexId}|cg=${r.collectionGroup}|f=${r.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${ce(e)}`);
          const o = function(t4, e2) {
            const n2 = ne(e2);
            if (n2 === void 0)
              return null;
            for (const e3 of de(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(i2, s2), a = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of se(e2))
              for (const e3 of de(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(i2, s2), u = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const r2 of se(e2)) {
              let e3, o2 = true;
              for (const n3 of de(t4, r2.fieldPath)) {
                let t5, s4 = true;
                switch (n3.op) {
                  case "<":
                  case "<=":
                    t5 = "nullValue" in (i3 = n3.value) ? kt : "booleanValue" in i3 ? {
                      booleanValue: false
                    } : "integerValue" in i3 || "doubleValue" in i3 ? {
                      doubleValue: NaN
                    } : "timestampValue" in i3 ? {
                      timestampValue: {
                        seconds: Number.MIN_SAFE_INTEGER
                      }
                    } : "stringValue" in i3 ? {
                      stringValue: ""
                    } : "bytesValue" in i3 ? {
                      bytesValue: ""
                    } : "referenceValue" in i3 ? Ut(vt.empty(), xt.empty()) : "geoPointValue" in i3 ? {
                      geoPointValue: {
                        latitude: -90,
                        longitude: -180
                      }
                    } : "arrayValue" in i3 ? {
                      arrayValue: {}
                    } : "mapValue" in i3 ? {
                      mapValue: {}
                    } : L2();
                    break;
                  case "==":
                  case "in":
                  case ">=":
                    t5 = n3.value;
                    break;
                  case ">":
                    t5 = n3.value, s4 = false;
                    break;
                  case "!=":
                  case "not-in":
                    t5 = kt;
                }
                Jt(e3, t5) === t5 && (e3 = t5, o2 = s4);
              }
              if (t4.startAt !== null) {
                for (let n3 = 0; n3 < t4.orderBy.length; ++n3)
                  if (t4.orderBy[n3].field.isEqual(r2.fieldPath)) {
                    const s4 = t4.startAt.position[n3];
                    Jt(e3, s4) === s4 && (e3 = s4, o2 = t4.startAt.inclusive);
                    break;
                  }
              }
              if (e3 === void 0)
                return null;
              n2.push(e3), s3 && (s3 = o2);
            }
            var i3;
            return new Ae(n2, s3);
          }(i2, s2), c = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const r2 of se(e2)) {
              let e3, o2 = true;
              for (const n3 of de(t4, r2.fieldPath)) {
                let t5, s4 = true;
                switch (n3.op) {
                  case ">=":
                  case ">":
                    t5 = "nullValue" in (i3 = n3.value) ? {
                      booleanValue: false
                    } : "booleanValue" in i3 ? {
                      doubleValue: NaN
                    } : "integerValue" in i3 || "doubleValue" in i3 ? {
                      timestampValue: {
                        seconds: Number.MIN_SAFE_INTEGER
                      }
                    } : "timestampValue" in i3 ? {
                      stringValue: ""
                    } : "stringValue" in i3 ? {
                      bytesValue: ""
                    } : "bytesValue" in i3 ? Ut(vt.empty(), xt.empty()) : "referenceValue" in i3 ? {
                      geoPointValue: {
                        latitude: -90,
                        longitude: -180
                      }
                    } : "geoPointValue" in i3 ? {
                      arrayValue: {}
                    } : "arrayValue" in i3 ? {
                      mapValue: {}
                    } : "mapValue" in i3 ? Nt : L2(), s4 = false;
                    break;
                  case "==":
                  case "in":
                  case "<=":
                    t5 = n3.value;
                    break;
                  case "<":
                    t5 = n3.value, s4 = false;
                    break;
                  case "!=":
                  case "not-in":
                    t5 = Nt;
                }
                Yt(e3, t5) === t5 && (e3 = t5, o2 = s4);
              }
              if (t4.endAt !== null) {
                for (let n3 = 0; n3 < t4.orderBy.length; ++n3)
                  if (t4.orderBy[n3].field.isEqual(r2.fieldPath)) {
                    const s4 = t4.endAt.position[n3];
                    Yt(e3, s4) === s4 && (e3 = s4, o2 = t4.endAt.inclusive);
                    break;
                  }
              }
              if (e3 === void 0)
                return null;
              n2.push(e3), s3 && (s3 = o2);
            }
            var i3;
            return new Ae(n2, s3);
          }(i2, s2), h = this.je(s2, i2, u), l2 = this.je(s2, i2, c), f = this.We(s2, i2, a), d = this.ze(s2.indexId, o, h, !!u && u.inclusive, l2, !!c && c.inclusive, f);
          return ui.forEach(d, (s3) => n.Gt(s3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              t3 = t3.add(new xt(Ls(e3.documentKey)));
            });
          }));
        }).next(() => t3);
      }
      return ui.resolve(null);
    });
  }
  Qe(t2) {
    let e = this.Ge.get(t2);
    return e || (e = [t2], this.Ge.set(t2, e), e);
  }
  ze(t2, e, n, s, i, r, o) {
    const a = (e != null ? e.length : 1) * Math.max(n != null ? n.length : 1, i != null ? i.length : 1), u = a / (e != null ? e.length : 1), c = [];
    for (let h = 0; h < a; ++h) {
      const a2 = e ? this.He(e[h / u]) : er, l2 = n ? this.Je(t2, a2, n[h % u], s) : this.Ye(t2), f = i ? this.Xe(t2, a2, i[h % u], r) : this.Ye(t2 + 1);
      c.push(...this.createRange(l2, f, o.map((e2) => this.Je(t2, a2, e2, true))));
    }
    return c;
  }
  Je(t2, e, n, s) {
    const i = new Hi(t2, xt.empty(), e, n);
    return s ? i : i.ke();
  }
  Xe(t2, e, n, s) {
    const i = new Hi(t2, xt.empty(), e, n);
    return s ? i.ke() : i;
  }
  Ye(t2) {
    return new Hi(t2, xt.empty(), er, er);
  }
  getFieldIndex(t2, e) {
    const n = new Xi(e), s = e.collectionGroup != null ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      const e2 = t3.filter((t4) => n.Fe(t4));
      return e2.sort((t4, e3) => e3.fields.length - t4.fields.length), e2.length > 0 ? e2[0] : null;
    });
  }
  Ze(t2, e) {
    const n = new zi();
    for (const s of se(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (t3 == null)
        return null;
      const i = n.Ne(s.kind);
      Ui.fe.Zt(t3, i);
    }
    return n.Se();
  }
  He(t2) {
    const e = new zi();
    return Ui.fe.Zt(t2, e.Ne(0)), e.Se();
  }
  We(t2, e, n) {
    if (n === null)
      return [];
    let s = [];
    s.push(new zi());
    let i = 0;
    for (const r of se(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.tn(e, r.fieldPath) && Gt(t3))
          s = this.en(s, r, t3);
        else {
          const e2 = n2.Ne(r.kind);
          Ui.fe.Zt(t3, e2);
        }
    }
    return this.nn(s);
  }
  je(t2, e, n) {
    return n == null ? null : this.We(t2, e, n.position);
  }
  nn(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].Se();
    return e;
  }
  en(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new zi();
        s2.seed(n2.Se()), Ui.fe.Zt(t3, s2.Ne(e.kind)), i.push(s2);
      }
    return i;
  }
  tn(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof _e && t3.field.isEqual(e) && (t3.op === "in" || t3.op === "not-in"));
  }
  getFieldIndexes(t2, e) {
    const n = rr(t2), s = or(t2);
    return (e ? n.Ut("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.Ut()).next((t3) => {
      const e2 = [];
      return ui.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new re(e3.sequenceNumber, new oe(Di(e3.readTime), new xt(Ls(e3.documentKey)), e3.largestBatchId)) : re.empty(), s2 = t5.fields.map(([t6, e4]) => new ie(mt.fromServerFormat(t6), e4));
          return new ee(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => t3.length === 0 ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return n !== 0 ? n : rt(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = rr(t2), i = or(t2);
    return this.sn(t2).next((t3) => s.Ut("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => ui.forEach(e2, (e3) => i.put(function(t4, e4, n2, s2) {
      return {
        indexId: t4,
        uid: e4.uid || "",
        sequenceNumber: n2,
        readTime: Si(s2.readTime),
        documentKey: $s(s2.documentKey.path),
        largestBatchId: s2.largestBatchId
      };
    }(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return ui.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? ui.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), ui.forEach(i2, (n2) => this.rn(t2, e2, n2).next((e3) => {
        const i3 = this.on(s, n2);
        return e3.isEqual(i3) ? ui.resolve() : this.an(t2, s, e3, i3);
      }))));
    });
  }
  un(t2, e, n) {
    return ir(t2).put({
      indexId: n.indexId,
      uid: this.uid,
      arrayValue: n.arrayValue,
      directionalValue: n.directionalValue,
      documentKey: $s(e.key.path)
    });
  }
  cn(t2, e, n) {
    return ir(t2).delete([n.indexId, this.uid, n.arrayValue, n.directionalValue, $s(e.key.path)]);
  }
  rn(t2, e, n) {
    const s = ir(t2);
    let i = new kn(Ji);
    return s.Wt({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, $s(e.path)])
    }, (t3, s2) => {
      i = i.add(new Hi(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  on(t2, e) {
    let n = new kn(Ji);
    const s = this.Ze(e, t2);
    if (s == null)
      return n;
    const i = ne(e);
    if (i != null) {
      const r = t2.data.field(i.fieldPath);
      if (Gt(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new Hi(e.indexId, t2.key, this.He(i2), s));
    } else
      n = n.add(new Hi(e.indexId, t2.key, er, s));
    return n;
  }
  an(t2, e, n, s) {
    O2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const i = [];
    return function(t3, e2, n2, s2, i2) {
      const r = t3.getIterator(), o = e2.getIterator();
      let a = On(r), u = On(o);
      for (; a || u; ) {
        let t4 = false, e3 = false;
        if (a && u) {
          const s3 = n2(a, u);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          a != null ? e3 = true : t4 = true;
        t4 ? (s2(u), u = On(o)) : e3 ? (i2(a), a = On(r)) : (a = On(r), u = On(o));
      }
    }(n, s, Ji, (n2) => {
      i.push(this.un(t2, e, n2));
    }, (n2) => {
      i.push(this.cn(t2, e, n2));
    }), ui.waitFor(i);
  }
  sn(t2) {
    let e = 1;
    return or(t2).Wt({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => Ji(t3, e2)).filter((t3, e2, n2) => !e2 || Ji(t3, n2[e2 - 1]) !== 0);
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = Ji(i2, t2), r = Ji(i2, e);
      if (n2 === 0)
        s[0] = t2.ke();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.ke());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2)
      i.push(IDBKeyRange.bound([s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, ""], [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, ""]));
    return i;
  }
};
function sr(t2) {
  return pi(t2, "collectionParents");
}
function ir(t2) {
  return pi(t2, "indexEntries");
}
function rr(t2) {
  return pi(t2, "indexConfiguration");
}
function or(t2) {
  return pi(t2, "indexState");
}
var ar = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var ur = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new ur(t2, ur.DEFAULT_COLLECTION_PERCENTILE, ur.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function cr(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let a = 0;
  const u = s.Wt({
    range: o
  }, (t3, e2, n2) => (a++, n2.delete()));
  r.push(u.next(() => {
    q2(a === 1);
  }));
  const c = [];
  for (const t3 of n.mutations) {
    const s2 = Ks(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), c.push(t3.key);
  }
  return ui.waitFor(r).next(() => c);
}
function hr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
ur.DEFAULT_COLLECTION_PERCENTILE = 10, ur.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, ur.DEFAULT = new ur(41943040, ur.DEFAULT_COLLECTION_PERCENTILE, ur.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), ur.DISABLED = new ur(-1, 0, 0);
var lr = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.M = e, this.indexManager = n, this.referenceDelegate = s, this.hn = {};
  }
  static Yt(t2, e, n, s) {
    q2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new lr(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return dr(t2).Wt({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = _r(t2), r = dr(t2);
    return r.add({}).next((o) => {
      q2(typeof o == "number");
      const a = new Ii(o, e, n, s), u = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => Ts(t3.Jt, e3)), i2 = n2.mutations.map((e3) => Ts(t3.Jt, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.M, this.userId, a), c = [];
      let h = new kn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ks(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), c.push(r.put(u)), c.push(i.put(e2, Gs));
      }
      return h.forEach((e2) => {
        c.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.hn[o] = a.keys();
      }), ui.waitFor(c).next(() => a);
    });
  }
  lookupMutationBatch(t2, e) {
    return dr(t2).get(e).next((t3) => t3 ? (q2(t3.userId === this.userId), Ci(this.M, t3)) : null);
  }
  ln(t2, e) {
    return this.hn[e] ? ui.resolve(this.hn[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.hn[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return dr(t2).Wt({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (q2(e2.batchId >= n), i = Ci(this.M, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return dr(t2).Wt({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return dr(t2).Ut("userMutationsIndex", e).next((t3) => t3.map((t4) => Ci(this.M, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Us(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return _r(t2).Wt({
      range: s
    }, (n2, s2, r) => {
      const [o, a, u] = n2, c = Ls(a);
      if (o === this.userId && e.path.isEqual(c))
        return dr(t2).get(u).next((t3) => {
          if (!t3)
            throw L2();
          q2(t3.userId === this.userId), i.push(Ci(this.M, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new kn(rt);
    const s = [];
    return e.forEach((e2) => {
      const i = Us(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = _r(t2).Wt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, a] = t3, u = Ls(o2);
        r2 === this.userId && e2.path.isEqual(u) ? n = n.add(a) : i2.done();
      });
      s.push(o);
    }), ui.waitFor(s).next(() => this.fn(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Us(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new kn(rt);
    return _r(t2).Wt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, a, u] = t3, c = Ls(a);
      r2 === this.userId && n.isPrefixOf(c) ? c.length === s && (o = o.add(u)) : i2.done();
    }).next(() => this.fn(t2, o));
  }
  fn(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(dr(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        q2(t3.userId === this.userId), n.push(Ci(this.M, t3));
      }));
    }), ui.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return cr(t2.Ht, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.dn(e.batchId);
    }), ui.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  dn(t2) {
    delete this.hn[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return ui.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return _r(t2).Wt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Ls(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        q2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return fr(t2, this.userId, e);
  }
  _n(t2) {
    return wr(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function fr(t2, e, n) {
  const s = Us(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return _r(t2).Wt({
    range: r,
    jt: true
  }, (t3, n2, s2) => {
    const [r2, a, u] = t3;
    r2 === e && a === i && (o = true), s2.done();
  }).next(() => o);
}
function dr(t2) {
  return pi(t2, "mutations");
}
function _r(t2) {
  return pi(t2, "documentMutations");
}
function wr(t2) {
  return pi(t2, "mutationQueues");
}
var mr = class {
  constructor(t2) {
    this.wn = t2;
  }
  next() {
    return this.wn += 2, this.wn;
  }
  static mn() {
    return new mr(0);
  }
  static gn() {
    return new mr(-1);
  }
};
var gr = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.M = e;
  }
  allocateTargetId(t2) {
    return this.yn(t2).next((e) => {
      const n = new mr(e.highestTargetId);
      return e.highestTargetId = n.next(), this.pn(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.yn(t2).next((t3) => ct.fromTimestamp(new ut(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.yn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.yn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.pn(t2, s)));
  }
  addTargetData(t2, e) {
    return this.In(t2, e).next(() => this.yn(t2).next((n) => (n.targetCount += 1, this.Tn(e, n), this.pn(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.In(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => yr(t2).delete(e.targetId)).next(() => this.yn(t2)).next((e2) => (q2(e2.targetCount > 0), e2.targetCount -= 1, this.pn(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return yr(t2).Wt((r, o) => {
      const a = xi(o);
      a.sequenceNumber <= e && n.get(a.targetId) === null && (s++, i.push(this.removeTargetData(t2, a)));
    }).next(() => ui.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return yr(t2).Wt((t3, n) => {
      const s = xi(n);
      e(s);
    });
  }
  yn(t2) {
    return pr(t2).get("targetGlobalKey").next((t3) => (q2(t3 !== null), t3));
  }
  pn(t2, e) {
    return pr(t2).put("targetGlobalKey", e);
  }
  In(t2, e) {
    return yr(t2).put(Ni(this.M, e));
  }
  Tn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.yn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = ce(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return yr(t2).Wt({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = xi(n2);
      le(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Ir(t2);
    return e.forEach((e2) => {
      const r = $s(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), ui.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Ir(t2);
    return ui.forEach(e, (e2) => {
      const i = $s(e2.path);
      return ui.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Ir(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Ir(t2);
    let i = Gn();
    return s.Wt({
      range: n,
      jt: true
    }, (t3, e2, n2) => {
      const s2 = Ls(t3[1]), r = new xt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = $s(e.path), s = IDBKeyRange.bound([n], [at(n)], false, true);
    let i = 0;
    return Ir(t2).Wt({
      index: "documentTargetsIndex",
      jt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return yr(t2).get(e).next((t3) => t3 ? xi(t3) : null);
  }
};
function yr(t2) {
  return pi(t2, "targets");
}
function pr(t2) {
  return pi(t2, "targetGlobal");
}
function Ir(t2) {
  return pi(t2, "targetDocuments");
}
async function Tr(t2) {
  if (t2.code !== G.FAILED_PRECONDITION || t2.message !== oi)
    throw t2;
  O2("LocalStore", "Unexpectedly lost primary lease");
}
function Er([t2, e], [n, s]) {
  const i = rt(t2, n);
  return i === 0 ? rt(e, s) : i;
}
var Ar = class {
  constructor(t2) {
    this.En = t2, this.buffer = new kn(Er), this.An = 0;
  }
  Rn() {
    return ++this.An;
  }
  bn(t2) {
    const e = [t2, this.Rn()];
    if (this.buffer.size < this.En)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Er(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Rr = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.Pn = false, this.Vn = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.vn(t2);
  }
  stop() {
    this.Vn && (this.Vn.cancel(), this.Vn = null);
  }
  get started() {
    return this.Vn !== null;
  }
  vn(t2) {
    const e = this.Pn ? 3e5 : 6e4;
    O2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Vn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.Vn = null, this.Pn = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        di(t3) ? O2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Tr(t3);
      }
      await this.vn(t2);
    });
  }
};
var br = class {
  constructor(t2, e) {
    this.Sn = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.Sn.Dn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return ui.resolve(nt.A);
    const n = new Ar(e);
    return this.Sn.forEachTarget(t2, (t3) => n.bn(t3.sequenceNumber)).next(() => this.Sn.Cn(t2, (t3) => n.bn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.Sn.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.Sn.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (O2("LruGarbageCollector", "Garbage collection skipped; disabled"), ui.resolve(ar)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (O2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), ar) : this.xn(t2, e));
  }
  getCacheSize(t2) {
    return this.Sn.getCacheSize(t2);
  }
  xn(t2, e) {
    let n, s, i, r, o, u, c;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (O2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, u = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (c = Date.now(), k2() <= LogLevel.DEBUG) {
        O2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (u - o) + `ms
	Removed ${t3} documents in ` + (c - u) + `ms
Total Duration: ${c - h}ms`);
      }
      return ui.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Pr = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new br(t3, e2);
    }(this, e);
  }
  Dn(t2) {
    const e = this.Nn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Nn(t2) {
    let e = 0;
    return this.Cn(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  Cn(t2, e) {
    return this.kn(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Vr(t2, n);
  }
  removeReference(t2, e, n) {
    return Vr(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Vr(t2, e);
  }
  Mn(t2, e) {
    return function(t3, e2) {
      let n = false;
      return wr(t3).zt((s) => fr(t3, s, e2).next((t4) => (t4 && (n = true), ui.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.kn(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Mn(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, ct.min()), Ir(t2).delete([0, $s(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => ui.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Vr(t2, e);
  }
  kn(t2, e) {
    const n = Ir(t2);
    let s, i = nt.A;
    return n.Wt({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== nt.A && e(new xt(Ls(s)), i), i = o, s = r) : i = nt.A;
    }).next(() => {
      i !== nt.A && e(new xt(Ls(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Vr(t2, e) {
  return Ir(t2).put(function(t3, e2) {
    return {
      targetId: 0,
      path: $s(t3.path),
      sequenceNumber: e2
    };
  }(e, t2.currentSequenceNumber));
}
var vr = class {
  constructor() {
    this.changes = new Dn((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, te.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? ui.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Sr = class {
  constructor(t2) {
    this.M = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return xr(t2).put(Nr(e), n);
  }
  removeEntry(t2, e) {
    const n = xr(t2), s = Nr(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.On(t2, n)));
  }
  getEntry(t2, e) {
    return xr(t2).get(Nr(e)).next((t3) => this.$n(e, t3));
  }
  Fn(t2, e) {
    return xr(t2).get(Nr(e)).next((t3) => ({
      document: this.$n(e, t3),
      size: hr(t3)
    }));
  }
  getEntries(t2, e) {
    let n = Fn();
    return this.Bn(t2, e, (t3, e2) => {
      const s = this.$n(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Ln(t2, e) {
    let n = Fn(), s = new Cn(xt.comparator);
    return this.Bn(t2, e, (t3, e2) => {
      const i = this.$n(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, hr(e2));
    }).next(() => ({
      documents: n,
      qn: s
    }));
  }
  Bn(t2, e, n) {
    if (e.isEmpty())
      return ui.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return xr(t2).Wt({
      range: s
    }, (t3, e2, s2) => {
      const o = xt.fromSegments(t3);
      for (; r && xt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.qt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getAll(t2, e, n) {
    let s = Fn();
    const i = e.length + 1, r = {};
    if (n.isEqual(ct.min())) {
      const t3 = e.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.toArray(), s2 = Vi(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = "collectionReadTimeIndex";
    }
    return xr(t2).Wt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = this.$n(xt.fromSegments(t3), n2);
      e.isPrefixOf(o.key.path) ? s = s.insert(o.key, o) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Dr(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Cr(t2).get("remoteDocumentGlobalKey").next((t3) => (q2(!!t3), t3));
  }
  On(t2, e) {
    return Cr(t2).put("remoteDocumentGlobalKey", e);
  }
  $n(t2, e) {
    if (e) {
      const t3 = bi(this.M, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ct.min())))
        return t3;
    }
    return te.newInvalidDocument(t2);
  }
};
var Dr = class extends vr {
  constructor(t2, e) {
    super(), this.Un = t2, this.trackRemovals = e, this.Kn = new Dn((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new kn((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Kn.get(i);
      if (r.isValidDocument()) {
        const a = Pi(this.Un.M, r);
        s = s.add(i.path.popLast());
        const u = hr(a);
        n += u - o, e.push(this.Un.addEntry(t2, i, a));
      } else if (n -= o, this.trackRemovals) {
        const n2 = Pi(this.Un.M, r.convertToNoDocument(ct.min()));
        e.push(this.Un.addEntry(t2, i, n2));
      } else
        e.push(this.Un.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Un.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Un.updateMetadata(t2, n)), ui.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Un.Fn(t2, e).next((t3) => (this.Kn.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Un.Ln(t2, e).next(({ documents: t3, qn: e2 }) => (e2.forEach((t4, e3) => {
      this.Kn.set(t4, e3);
    }), t3));
  }
};
function Cr(t2) {
  return pi(t2, "remoteDocumentGlobal");
}
function xr(t2) {
  return pi(t2, "remoteDocuments");
}
function Nr(t2) {
  return t2.path.toArray();
}
var kr = class {
  constructor(t2) {
    this.M = t2;
  }
  kt(t2, e, n, s) {
    const i = new ci("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", qs, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), Mr(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = ui.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), Mr(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: ct.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").Ut().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", qs, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return ui.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Gn(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.Qn(i)))), n < 7 && s >= 7 && (r = r.next(() => this.jn(i))), n < 8 && s >= 8 && (r = r.next(() => this.Wn(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore("remoteDocuments");
        e2.createIndex("readTimeIndex", "readTime", {
          unique: false
        }), e2.createIndex("collectionReadTimeIndex", Qs, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.zn(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: ti
        });
        e2.createIndex("collectionPathOverlayIndex", ei, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", ni, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("indexConfiguration", {
          keyPath: "indexId",
          autoIncrement: true
        }).createIndex("collectionGroupIndex", "collectionGroup", {
          unique: false
        });
        t3.createObjectStore("indexState", {
          keyPath: Js
        }).createIndex("sequenceNumberIndex", Ys, {
          unique: false
        });
        t3.createObjectStore("indexEntries", {
          keyPath: Xs
        }).createIndex("documentKeyIndex", Zs, {
          unique: false
        });
      }(t2);
    })), r;
  }
  Qn(t2) {
    let e = 0;
    return t2.store("remoteDocuments").Wt((t3, n) => {
      e += hr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  Gn(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.Ut().next((e2) => ui.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Ut("userMutationsIndex", s).next((n2) => ui.forEach(n2, (n3) => {
        q2(n3.userId === e3.userId);
        const s2 = Ci(this.M, n3);
        return cr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  jn(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.Wt((n2, i) => {
        const r = new _t(n2), o = function(t4) {
          return [0, $s(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? ui.resolve() : ((n4) => e.put({
          targetId: 0,
          path: $s(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => ui.waitFor(s));
    });
  }
  Wn(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: Hs
    });
    const n = e.store("collectionParents"), s = new tr(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: $s(s2)
        });
      }
    };
    return e.store("remoteDocuments").Wt({
      jt: true
    }, (t3, e2) => {
      const n2 = new _t(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").Wt({
      jt: true
    }, ([t3, e2, n2], s2) => {
      const r = Ls(e2);
      return i(r.popLast());
    }));
  }
  zn(t2) {
    const e = t2.store("targets");
    return e.Wt((t3, n) => {
      const s = xi(n), i = Ni(this.M, s);
      return e.put(i);
    });
  }
};
function Mr(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: Ws
  }).createIndex("documentTargetsIndex", zs, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", js, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var Or = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var $r = class {
  constructor(t2, e, n, s, i, r, o, a, u, c, h = 12) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Hn = i, this.window = r, this.document = o, this.Jn = u, this.Yn = c, this.Xn = h, this.Zn = null, this.ts = false, this.isPrimary = false, this.networkEnabled = true, this.es = null, this.inForeground = false, this.ns = null, this.ss = null, this.rs = Number.NEGATIVE_INFINITY, this.os = (t3) => Promise.resolve(), !$r.vt())
      throw new Q2(G.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Pr(this, s), this.us = e + "main", this.M = new Ri(a), this.cs = new hi(this.us, this.Xn, new kr(this.M)), this.hs = new gr(this.referenceDelegate, this.M), this.ls = function(t3) {
      return new Sr(t3);
    }(this.M), this.fs = new $i(), this.window && this.window.localStorage ? this.ds = this.window.localStorage : (this.ds = null, c === false && $("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this._s().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q2(G.FAILED_PRECONDITION, Or);
      return this.ws(), this.gs(), this.ys(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.hs.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Zn = new nt(t2, this.Jn);
    }).then(() => {
      this.ts = true;
    }).catch((t2) => (this.cs && this.cs.close(), Promise.reject(t2)));
  }
  ps(t2) {
    return this.os = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.cs.Ot(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Hn.enqueueAndForget(async () => {
      this.started && await this._s();
    }));
  }
  _s() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Br(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.Is(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Hn.enqueueRetryable(() => this.os(false)));
        });
    }).next(() => this.Ts(t2)).next((e) => this.isPrimary && !e ? this.Es(t2).next(() => false) : !!e && this.As(t2).next(() => true))).catch((t2) => {
      if (di(t2))
        return O2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return O2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Hn.enqueueRetryable(() => this.os(t2)), this.isPrimary = t2;
    });
  }
  Is(t2) {
    return Fr(t2).get("owner").next((t3) => ui.resolve(this.Rs(t3)));
  }
  bs(t2) {
    return Br(t2).delete(this.clientId);
  }
  async Ps() {
    if (this.isPrimary && !this.Vs(this.rs, 18e5)) {
      this.rs = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = pi(t3, "clientMetadata");
        return e.Ut().next((t4) => {
          const n = this.vs(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return ui.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.ds)
        for (const e of t2)
          this.ds.removeItem(this.Ss(e.clientId));
    }
  }
  ys() {
    this.ss = this.Hn.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this._s().then(() => this.Ps()).then(() => this.ys()));
  }
  Rs(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  Ts(t2) {
    if (this.Yn)
      return ui.resolve(true);
    return Fr(t2).get("owner").next((e) => {
      if (e !== null && this.Vs(e.leaseTimestampMs, 5e3) && !this.Ds(e.ownerId)) {
        if (this.Rs(e) && this.networkEnabled)
          return true;
        if (!this.Rs(e)) {
          if (!e.allowTabSynchronization)
            throw new Q2(G.FAILED_PRECONDITION, Or);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Br(t2).Ut().next((t3) => this.vs(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && O2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.ts = false, this.Cs(), this.ss && (this.ss.cancel(), this.ss = null), this.xs(), this.Ns(), await this.cs.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new yi(t2, nt.A);
      return this.Es(e).next(() => this.bs(e));
    }), this.cs.close(), this.ks();
  }
  vs(t2, e) {
    return t2.filter((t3) => this.Vs(t3.updateTimeMs, e) && !this.Ds(t3.clientId));
  }
  Ms() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Br(t2).Ut().next((t3) => this.vs(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.ts;
  }
  getMutationQueue(t2, e) {
    return lr.Yt(t2, this.M, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.hs;
  }
  getRemoteDocumentCache() {
    return this.ls;
  }
  getIndexManager(t2) {
    return new nr(t2);
  }
  getDocumentOverlayCache(t2) {
    return Li.Yt(this.M, t2);
  }
  getBundleCache() {
    return this.fs;
  }
  runTransaction(t2, e, n) {
    O2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite", i = (r = this.Xn) === 13 ? ri : r === 12 ? ii : r === 11 ? si : void L2();
    var r;
    let o;
    return this.cs.runTransaction(t2, s, i, (s2) => (o = new yi(s2, this.Zn ? this.Zn.next() : nt.A), e === "readwrite-primary" ? this.Is(o).next((t3) => !!t3 || this.Ts(o)).next((e2) => {
      if (!e2)
        throw $(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Hn.enqueueRetryable(() => this.os(false)), new Q2(G.FAILED_PRECONDITION, oi);
      return n(o);
    }).next((t3) => this.As(o).next(() => t3)) : this.Os(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  Os(t2) {
    return Fr(t2).get("owner").next((t3) => {
      if (t3 !== null && this.Vs(t3.leaseTimestampMs, 5e3) && !this.Ds(t3.ownerId) && !this.Rs(t3) && !(this.Yn || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new Q2(G.FAILED_PRECONDITION, Or);
    });
  }
  As(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return Fr(t2).put("owner", e);
  }
  static vt() {
    return hi.vt();
  }
  Es(t2) {
    const e = Fr(t2);
    return e.get("owner").next((t3) => this.Rs(t3) ? (O2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : ui.resolve());
  }
  Vs(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || ($(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  ws() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.ns = () => {
      this.Hn.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this._s()));
    }, this.document.addEventListener("visibilitychange", this.ns), this.inForeground = this.document.visibilityState === "visible");
  }
  xs() {
    this.ns && (this.document.removeEventListener("visibilitychange", this.ns), this.ns = null);
  }
  gs() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.es = () => {
      this.Cs(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Hn.enterRestrictedMode(true), this.Hn.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.es));
  }
  Ns() {
    this.es && (this.window.removeEventListener("pagehide", this.es), this.es = null);
  }
  Ds(t2) {
    var e;
    try {
      const n = ((e = this.ds) === null || e === void 0 ? void 0 : e.getItem(this.Ss(t2))) !== null;
      return O2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return $("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  Cs() {
    if (this.ds)
      try {
        this.ds.setItem(this.Ss(this.clientId), String(Date.now()));
      } catch (t2) {
        $("Failed to set zombie client id.", t2);
      }
  }
  ks() {
    if (this.ds)
      try {
        this.ds.removeItem(this.Ss(this.clientId));
      } catch (t2) {
      }
  }
  Ss(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function Fr(t2) {
  return pi(t2, "owner");
}
function Br(t2) {
  return pi(t2, "clientMetadata");
}
function Lr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var qr = class {
  constructor(t2, e) {
    this.progress = t2, this.$s = e;
  }
};
var Ur = class {
  constructor(t2, e, n) {
    this.ls = t2, this.Fs = e, this.indexManager = n;
  }
  Bs(t2, e) {
    return this.Fs.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Ls(t2, e, n));
  }
  Ls(t2, e, n) {
    return this.ls.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  qs(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  Us(t2, e) {
    return this.ls.getEntries(t2, e).next((e2) => this.Ks(t2, e2).next(() => e2));
  }
  Ks(t2, e) {
    return this.Fs.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.qs(e, t3));
  }
  Gs(t2, e, n) {
    return function(t3) {
      return xt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Qs(t2, e.path) : Me(e) ? this.js(t2, e, n) : this.Ws(t2, e, n);
  }
  Qs(t2, e) {
    return this.Bs(t2, new xt(e)).next((t3) => {
      let e2 = Ln();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  js(t2, e, n) {
    const s = e.collectionGroup;
    let i = Ln();
    return this.indexManager.getCollectionParents(t2, s).next((r) => ui.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new ve(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Ws(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Ws(t2, e, n) {
    let s;
    return this.ls.getAll(t2, e.path, n).next((n2) => (s = n2, this.Fs.getAllMutationBatchesAffectingQuery(t2, e))).next((t3) => {
      for (const e2 of t3)
        for (const t4 of e2.mutations) {
          const n2 = t4.key;
          let i = s.get(n2);
          i == null && (i = te.newInvalidDocument(n2), s = s.insert(n2, i)), _n(t4, i, e2.localWriteTime), i.isFoundDocument() || (s = s.remove(n2));
        }
    }).next(() => (s.forEach((t3, n2) => {
      Ue(e, n2) || (s = s.remove(t3));
    }), s));
  }
};
var Kr = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.zs = n, this.Hs = s;
  }
  static Js(t2, e) {
    let n = Gn(), s = Gn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new Kr(t2, e.fromCache, n, s);
  }
};
var Gr = class {
  Ys(t2) {
    this.Xs = t2;
  }
  Gs(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(ct.min()) ? this.Zs(t2, e) : this.Xs.Us(t2, s).next((i) => {
      const r = this.ti(e, i);
      return (Ce(e) || xe(e)) && this.ei(e.limitType, r, s, n) ? this.Zs(t2, e) : (k2() <= LogLevel.DEBUG && O2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), qe(e)), this.Xs.Gs(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  ti(t2, e) {
    let n = new kn(Ke(t2));
    return e.forEach((e2, s) => {
      Ue(t2, s) && (n = n.add(s));
    }), n;
  }
  ei(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Zs(t2, e) {
    return k2() <= LogLevel.DEBUG && O2("QueryEngine", "Using full collection scan to execute query:", qe(e)), this.Xs.Gs(t2, e, ct.min());
  }
};
var Qr = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.ni = e, this.M = s, this.si = new Cn(rt), this.ii = new Dn((t3) => ce(t3), le), this.ri = ct.min(), this.oi = t2.getRemoteDocumentCache(), this.hs = t2.getTargetCache(), this.fs = t2.getBundleCache(), this.ai(n);
  }
  ai(t2) {
    this.indexManager = this.persistence.getIndexManager(t2), this.Fs = this.persistence.getMutationQueue(t2, this.indexManager), this.ui = new Ur(this.oi, this.Fs, this.indexManager), this.oi.setIndexManager(this.indexManager), this.ni.Ys(this.ui);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.si));
  }
};
function jr(t2, e, n, s) {
  return new Qr(t2, e, n, s);
}
async function Wr(t2, e) {
  const n = K2(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.Fs.getAllMutationBatches(t3).next((i) => (s = i, n.ai(e), n.Fs.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = Gn();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.ui.Us(t3, o).next((t4) => ({
        ci: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function zr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.oi.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = ui.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          q2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.Fs.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.Fs.performConsistencyCheck(t3)).next(() => n.ui.Us(t3, s));
  });
}
function Hr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.hs.getLastRemoteSnapshotVersion(t3));
}
function Jr(t2, e) {
  const n = K2(t2), s = e.snapshotVersion;
  let i = n.si;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.oi.newChangeBuffer({
      trackRemovals: true
    });
    i = n.si;
    const o = [];
    e.targetChanges.forEach((r2, a2) => {
      const u = i.get(a2);
      if (!u)
        return;
      o.push(n.hs.removeMatchingKeys(t3, r2.removedDocuments, a2).next(() => n.hs.addMatchingKeys(t3, r2.addedDocuments, a2)));
      let c = u.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(a2) ? c = c.withResumeToken(pt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r2.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(r2.resumeToken, s)), i = i.insert(a2, c), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(u, c, r2) && o.push(n.hs.updateTargetData(t3, c));
    });
    let a = Fn();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(Yr(t3, r, e.documentUpdates).next((t4) => {
      a = t4;
    })), !s.isEqual(ct.min())) {
      const e2 = n.hs.getLastRemoteSnapshotVersion(t3).next((e3) => n.hs.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return ui.waitFor(o).next(() => r.apply(t3)).next(() => n.ui.Ks(t3, a)).next(() => a);
  }).then((t3) => (n.si = i, t3));
}
function Yr(t2, e, n) {
  let s = Gn();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = Fn();
    return n.forEach((n2, i) => {
      const r = t3.get(n2);
      i.isNoDocument() && i.version.isEqual(ct.min()) ? (e.removeEntry(n2, i.readTime), s2 = s2.insert(n2, i)) : !r.isValidDocument() || i.version.compareTo(r.version) > 0 || i.version.compareTo(r.version) === 0 && r.hasPendingWrites ? (e.addEntry(i), s2 = s2.insert(n2, i)) : O2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", r.version, " Watch version:", i.version);
    }), s2;
  });
}
function Xr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.Fs.getNextMutationBatchAfterBatchId(t3, e)));
}
function Zr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.hs.getTargetData(t3, e).next((i) => i ? (s = i, ui.resolve(s)) : n.hs.allocateTargetId(t3).next((i2) => (s = new Ai(e, i2, 0, t3.currentSequenceNumber), n.hs.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.si.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.si = n.si.insert(t3.targetId, t3), n.ii.set(e, t3.targetId)), t3;
  });
}
async function to(t2, e, n) {
  const s = K2(t2), i = s.si.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!di(t3))
      throw t3;
    O2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.si = s.si.remove(e), s.ii.delete(i.target);
}
function eo(t2, e, n) {
  const s = K2(t2);
  let i = ct.min(), r = Gn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = K2(t4), i2 = s2.ii.get(n2);
    return i2 !== void 0 ? ui.resolve(s2.si.get(i2)) : s2.hs.getTargetData(e2, n2);
  }(s, t3, $e(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.hs.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.ni.Gs(t3, e, n ? i : ct.min(), n ? r : Gn())).next((t4) => ({
    documents: t4,
    hi: r
  })));
}
function no(t2, e) {
  const n = K2(t2), s = K2(n.hs), i = n.si.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function so(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = K2(t4);
    let i = Fn(), r = Vi(n);
    const o = xr(e2), a = IDBKeyRange.lowerBound(r, true);
    return o.Wt({
      index: "readTimeIndex",
      range: a
    }, (t5, e3) => {
      const n2 = bi(s.M, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      $s: i,
      readTime: vi(r)
    }));
  }(e.oi, t3, e.ri)).then(({ $s: t3, readTime: n }) => (e.ri = n, t3));
}
async function io(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = xr(t4);
    let n = ct.min();
    return e2.Wt({
      index: "readTimeIndex",
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = vi(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.ri = t3;
  });
}
async function ro(t2, e, n, s) {
  const i = K2(t2);
  let r = Gn(), o = Fn();
  for (const t3 of n) {
    const n2 = e.li(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.fi(t3);
    s2.setReadTime(e.di(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const a = i.oi.newChangeBuffer({
    trackRemovals: true
  }), u = await Zr(i, function(t3) {
    return $e(De(_t.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => Yr(t3, a, o).next((e2) => (a.apply(t3), e2)).next((e2) => i.hs.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.hs.addMatchingKeys(t3, r, u.targetId)).next(() => i.ui.Ks(t3, e2)).next(() => e2)));
}
async function oo(t2, e, n = Gn()) {
  const s = await Zr(t2, $e(ki(e.bundledQuery))), i = K2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = us(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.fs.saveNamedQuery(t3, e);
    const o = s.withResumeToken(pt.EMPTY_BYTE_STRING, r);
    return i.si = i.si.insert(o.targetId, o), i.hs.updateTargetData(t3, o).next(() => i.hs.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.hs.addMatchingKeys(t3, n, s.targetId)).next(() => i.fs.saveNamedQuery(t3, e));
  });
}
var ao = class {
  constructor(t2) {
    this.M = t2, this._i = /* @__PURE__ */ new Map(), this.wi = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return ui.resolve(this._i.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this._i.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: us(n.createTime)
    }), ui.resolve();
  }
  getNamedQuery(t2, e) {
    return ui.resolve(this.wi.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.wi.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: ki(t3.bundledQuery),
        readTime: us(t3.readTime)
      };
    }(e)), ui.resolve();
  }
};
var uo = class {
  constructor() {
    this.overlays = new Cn(xt.comparator), this.mi = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return ui.resolve(this.overlays.get(e));
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.Xt(t2, e, s);
    }), ui.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.mi.get(n);
    return s !== void 0 && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.mi.delete(n)), ui.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = qn(), i = e.length + 1, r = new xt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return ui.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new Cn((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        e2 === null && (e2 = qn(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = qn(), a = i.getIterator();
    for (; a.hasNext(); ) {
      if (a.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return ui.resolve(o);
  }
  Xt(t2, e, n) {
    if (n === null)
      return;
    const s = this.overlays.get(n.key);
    if (s !== null) {
      const t3 = this.mi.get(s.largestBatchId).delete(n.key);
      this.mi.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Ei(e, n));
    let i = this.mi.get(e);
    i === void 0 && (i = Gn(), this.mi.set(e, i)), this.mi.set(e, i.add(n.key));
  }
};
var co = class {
  constructor() {
    this.gi = new kn(ho.yi), this.pi = new kn(ho.Ii);
  }
  isEmpty() {
    return this.gi.isEmpty();
  }
  addReference(t2, e) {
    const n = new ho(t2, e);
    this.gi = this.gi.add(n), this.pi = this.pi.add(n);
  }
  Ti(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.Ei(new ho(t2, e));
  }
  Ai(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  Ri(t2) {
    const e = new xt(new _t([])), n = new ho(e, t2), s = new ho(e, t2 + 1), i = [];
    return this.pi.forEachInRange([n, s], (t3) => {
      this.Ei(t3), i.push(t3.key);
    }), i;
  }
  bi() {
    this.gi.forEach((t2) => this.Ei(t2));
  }
  Ei(t2) {
    this.gi = this.gi.delete(t2), this.pi = this.pi.delete(t2);
  }
  Pi(t2) {
    const e = new xt(new _t([])), n = new ho(e, t2), s = new ho(e, t2 + 1);
    let i = Gn();
    return this.pi.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new ho(t2, 0), n = this.gi.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var ho = class {
  constructor(t2, e) {
    this.key = t2, this.Vi = e;
  }
  static yi(t2, e) {
    return xt.comparator(t2.key, e.key) || rt(t2.Vi, e.Vi);
  }
  static Ii(t2, e) {
    return rt(t2.Vi, e.Vi) || xt.comparator(t2.key, e.key);
  }
};
var lo = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.Fs = [], this.vi = 1, this.Si = new kn(ho.yi);
  }
  checkEmpty(t2) {
    return ui.resolve(this.Fs.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.vi;
    this.vi++, this.Fs.length > 0 && this.Fs[this.Fs.length - 1];
    const r = new Ii(i, e, n, s);
    this.Fs.push(r);
    for (const e2 of s)
      this.Si = this.Si.add(new ho(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return ui.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return ui.resolve(this.Di(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.Ci(n), i = s < 0 ? 0 : s;
    return ui.resolve(this.Fs.length > i ? this.Fs[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return ui.resolve(this.Fs.length === 0 ? -1 : this.vi - 1);
  }
  getAllMutationBatches(t2) {
    return ui.resolve(this.Fs.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new ho(e, 0), s = new ho(e, Number.POSITIVE_INFINITY), i = [];
    return this.Si.forEachInRange([n, s], (t3) => {
      const e2 = this.Di(t3.Vi);
      i.push(e2);
    }), ui.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new kn(rt);
    return e.forEach((t3) => {
      const e2 = new ho(t3, 0), s = new ho(t3, Number.POSITIVE_INFINITY);
      this.Si.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.Vi);
      });
    }), ui.resolve(this.xi(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    xt.isDocumentKey(i) || (i = i.child(""));
    const r = new ho(new xt(i), 0);
    let o = new kn(rt);
    return this.Si.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.Vi)), true);
    }, r), ui.resolve(this.xi(o));
  }
  xi(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.Di(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    q2(this.Ni(e.batchId, "removed") === 0), this.Fs.shift();
    let n = this.Si;
    return ui.forEach(e.mutations, (s) => {
      const i = new ho(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.Si = n;
    });
  }
  dn(t2) {
  }
  containsKey(t2, e) {
    const n = new ho(e, 0), s = this.Si.firstAfterOrEqual(n);
    return ui.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.Fs.length, ui.resolve();
  }
  Ni(t2, e) {
    return this.Ci(t2);
  }
  Ci(t2) {
    if (this.Fs.length === 0)
      return 0;
    return t2 - this.Fs[0].batchId;
  }
  Di(t2) {
    const e = this.Ci(t2);
    if (e < 0 || e >= this.Fs.length)
      return null;
    return this.Fs[e];
  }
};
var fo = class {
  constructor(t2) {
    this.ki = t2, this.docs = new Cn(xt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.ki(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return ui.resolve(n ? n.document.mutableCopy() : te.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = Fn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : te.newInvalidDocument(t3));
    }), ui.resolve(n);
  }
  getAll(t2, e, n) {
    let s = Fn();
    const i = new xt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t3.path))
        break;
      t3.path.length > e.length + 1 || (i2.readTime.compareTo(n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return ui.resolve(s);
  }
  Mi(t2, e) {
    return ui.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new _o(this);
  }
  getSize(t2) {
    return ui.resolve(this.size);
  }
};
var _o = class extends vr {
  constructor(t2) {
    super(), this.Un = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.Un.addEntry(t2, s)) : this.Un.removeEntry(n);
    }), ui.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Un.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Un.getEntries(t2, e);
  }
};
var wo = class {
  constructor(t2) {
    this.persistence = t2, this.Oi = new Dn((t3) => ce(t3), le), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.$i = 0, this.Fi = new co(), this.targetCount = 0, this.Bi = mr.mn();
  }
  forEachTarget(t2, e) {
    return this.Oi.forEach((t3, n) => e(n)), ui.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return ui.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return ui.resolve(this.$i);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Bi.next(), ui.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.$i && (this.$i = e), ui.resolve();
  }
  In(t2) {
    this.Oi.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Bi = new mr(e), this.highestTargetId = e), t2.sequenceNumber > this.$i && (this.$i = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.In(e), this.targetCount += 1, ui.resolve();
  }
  updateTargetData(t2, e) {
    return this.In(e), ui.resolve();
  }
  removeTargetData(t2, e) {
    return this.Oi.delete(e.target), this.Fi.Ri(e.targetId), this.targetCount -= 1, ui.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Oi.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Oi.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), ui.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return ui.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Oi.get(e) || null;
    return ui.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.Fi.Ti(e, n), ui.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.Fi.Ai(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), ui.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.Fi.Ri(e), ui.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.Fi.Pi(e);
    return ui.resolve(n);
  }
  containsKey(t2, e) {
    return ui.resolve(this.Fi.containsKey(e));
  }
};
var mo = class {
  constructor(t2, e) {
    this.Li = {}, this.overlays = {}, this.Zn = new nt(0), this.ts = false, this.ts = true, this.referenceDelegate = t2(this), this.hs = new wo(this);
    this.indexManager = new Zi(), this.ls = function(t3) {
      return new fo(t3);
    }((t3) => this.referenceDelegate.qi(t3)), this.M = new Ri(e), this.fs = new ao(this.M);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.ts = false, Promise.resolve();
  }
  get started() {
    return this.ts;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new uo(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.Li[t2.toKey()];
    return n || (n = new lo(e, this.referenceDelegate), this.Li[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.hs;
  }
  getRemoteDocumentCache() {
    return this.ls;
  }
  getBundleCache() {
    return this.fs;
  }
  runTransaction(t2, e, n) {
    O2("MemoryPersistence", "Starting transaction:", t2);
    const s = new go(this.Zn.next());
    return this.referenceDelegate.Ui(), n(s).next((t3) => this.referenceDelegate.Ki(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Gi(t2, e) {
    return ui.or(Object.values(this.Li).map((n) => () => n.containsKey(t2, e)));
  }
};
var go = class extends ai {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var yo = class {
  constructor(t2) {
    this.persistence = t2, this.Qi = new co(), this.ji = null;
  }
  static Wi(t2) {
    return new yo(t2);
  }
  get zi() {
    if (this.ji)
      return this.ji;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.Qi.addReference(n, e), this.zi.delete(n.toString()), ui.resolve();
  }
  removeReference(t2, e, n) {
    return this.Qi.removeReference(n, e), this.zi.add(n.toString()), ui.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.zi.add(e.toString()), ui.resolve();
  }
  removeTarget(t2, e) {
    this.Qi.Ri(e.targetId).forEach((t3) => this.zi.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.zi.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Ui() {
    this.ji = /* @__PURE__ */ new Set();
  }
  Ki(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return ui.forEach(this.zi, (n) => {
      const s = xt.fromPath(n);
      return this.Hi(t2, s).next((t3) => {
        t3 || e.removeEntry(s, ct.min());
      });
    }).next(() => (this.ji = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Hi(t2, e).next((t3) => {
      t3 ? this.zi.delete(e.toString()) : this.zi.add(e.toString());
    });
  }
  qi(t2) {
    return 0;
  }
  Hi(t2, e) {
    return ui.or([() => ui.resolve(this.Qi.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Gi(t2, e)]);
  }
};
function po(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Io(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function To(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var Eo = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Ji(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new Q2(s.error.code, s.error.message))), r ? new Eo(t2, e, s.state, i) : ($("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Ao = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new Q2(n.error.code, n.error.message))), i ? new Ao(t2, n.state, s) : ($("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Yi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Ro = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Ji(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = jn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Ct(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Ro(t2, i) : ($("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var bo = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Ji(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new bo(e.clientId, e.onlineState) : ($("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Po = class {
  constructor() {
    this.activeTargetIds = jn();
  }
  Xi(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Zi(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Yi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Vo = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Hn = e, this.persistenceKey = n, this.tr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.er = this.nr.bind(this), this.sr = new Cn(rt), this.started = false, this.ir = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.rr = po(this.persistenceKey, this.tr), this.ar = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.sr = this.sr.insert(this.tr, new Po()), this.ur = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.cr = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.hr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.lr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.dr = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.er);
  }
  static vt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Ms();
    for (const e2 of t2) {
      if (e2 === this.tr)
        continue;
      const t3 = this.getItem(po(this.persistenceKey, e2));
      if (t3) {
        const n = Ro.Ji(e2, t3);
        n && (this.sr = this.sr.insert(n.clientId, n));
      }
    }
    this._r();
    const e = this.storage.getItem(this.lr);
    if (e) {
      const t3 = this.wr(e);
      t3 && this.mr(t3);
    }
    for (const t3 of this.ir)
      this.nr(t3);
    this.ir = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.ar, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.gr(this.sr);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.sr.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.yr(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.yr(t2, e, n), this.pr(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(To(this.persistenceKey, t2));
      if (n) {
        const s = Ao.Ji(t2, n);
        s && (e = s.state);
      }
    }
    return this.Ir.Xi(t2), this._r(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Ir.Zi(t2), this._r();
  }
  isLocalQueryTarget(t2) {
    return this.Ir.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(To(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Tr(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.pr(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Er(t2);
  }
  notifyBundleLoaded() {
    this.Ar();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.er), this.removeItem(this.rr), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return O2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    O2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    O2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  nr(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (O2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.rr)
        return void $("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Hn.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.ur.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.Rr(e.key);
                return this.br(t3, null);
              }
              {
                const t3 = this.Pr(e.key, e.newValue);
                if (t3)
                  return this.br(t3.clientId, t3);
              }
            } else if (this.cr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Vr(e.key, e.newValue);
                if (t3)
                  return this.vr(t3);
              }
            } else if (this.hr.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.Sr(e.key, e.newValue);
                if (t3)
                  return this.Dr(t3);
              }
            } else if (e.key === this.lr) {
              if (e.newValue !== null) {
                const t3 = this.wr(e.newValue);
                if (t3)
                  return this.mr(t3);
              }
            } else if (e.key === this.ar) {
              const t3 = function(t4) {
                let e2 = nt.A;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    q2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    $("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== nt.A && this.sequenceNumberHandler(t3);
            } else if (e.key === this.dr)
              return this.syncEngine.Cr();
          }
        } else
          this.ir.push(e);
      });
    }
  }
  get Ir() {
    return this.sr.get(this.tr);
  }
  _r() {
    this.setItem(this.rr, this.Ir.Yi());
  }
  yr(t2, e, n) {
    const s = new Eo(this.currentUser, t2, e, n), i = Io(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Yi());
  }
  pr(t2) {
    const e = Io(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Er(t2) {
    const e = {
      clientId: this.tr,
      onlineState: t2
    };
    this.storage.setItem(this.lr, JSON.stringify(e));
  }
  Tr(t2, e, n) {
    const s = To(this.persistenceKey, t2), i = new Ao(t2, e, n);
    this.setItem(s, i.Yi());
  }
  Ar() {
    this.setItem(this.dr, "value-not-used");
  }
  Rr(t2) {
    const e = this.ur.exec(t2);
    return e ? e[1] : null;
  }
  Pr(t2, e) {
    const n = this.Rr(t2);
    return Ro.Ji(n, e);
  }
  Vr(t2, e) {
    const n = this.cr.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return Eo.Ji(new C2(i), s, e);
  }
  Sr(t2, e) {
    const n = this.hr.exec(t2), s = Number(n[1]);
    return Ao.Ji(s, e);
  }
  wr(t2) {
    return bo.Ji(t2);
  }
  async vr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.Nr(t2.batchId, t2.state, t2.error);
    O2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  Dr(t2) {
    return this.syncEngine.kr(t2.targetId, t2.state, t2.error);
  }
  br(t2, e) {
    const n = e ? this.sr.insert(t2, e) : this.sr.remove(t2), s = this.gr(this.sr), i = this.gr(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Mr(r, o).then(() => {
      this.sr = n;
    });
  }
  mr(t2) {
    this.sr.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  gr(t2) {
    let e = jn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var vo = class {
  constructor() {
    this.Or = new Po(), this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.Or.Xi(t2), this.$r[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.$r[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.Or.Zi(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Or.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.$r[t2];
  }
  getAllActiveQueryTargets() {
    return this.Or.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Or.activeTargetIds.has(t2);
  }
  start() {
    return this.Or = new Po(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var So = class {
  Fr(t2) {
  }
  shutdown() {
  }
};
var Do = class {
  constructor() {
    this.Br = () => this.Lr(), this.qr = () => this.Ur(), this.Kr = [], this.Gr();
  }
  Fr(t2) {
    this.Kr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Br), window.removeEventListener("offline", this.qr);
  }
  Gr() {
    window.addEventListener("online", this.Br), window.addEventListener("offline", this.qr);
  }
  Lr() {
    O2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Kr)
      t2(0);
  }
  Ur() {
    O2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Kr)
      t2(1);
  }
  static vt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Co = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var xo = class {
  constructor(t2) {
    this.Qr = t2.Qr, this.jr = t2.jr;
  }
  Wr(t2) {
    this.zr = t2;
  }
  Hr(t2) {
    this.Jr = t2;
  }
  onMessage(t2) {
    this.Yr = t2;
  }
  close() {
    this.jr();
  }
  send(t2) {
    this.Qr(t2);
  }
  Xr() {
    this.zr();
  }
  Zr(t2) {
    this.Jr(t2);
  }
  eo(t2) {
    this.Yr(t2);
  }
};
var No = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.no = e + "://" + t2.host, this.so = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  io(t2, e, n, s, i) {
    const r = this.ro(t2, e);
    O2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.oo(o, s, i), this.ao(t2, r, o, n).then((t3) => (O2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw F2("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  uo(t2, e, n, s, i) {
    return this.io(t2, e, n, s, i);
  }
  oo(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + x2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  ro(t2, e) {
    const n = Co[t2];
    return `${this.no}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  ao(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              O2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              O2("Connection", 'RPC "' + t2 + '" timed out'), r(new Q2(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (O2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e4) >= 0 ? e4 : G.UNKNOWN;
                  }(t3.status);
                  r(new Q2(e3, t3.message));
                } else
                  r(new Q2(G.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q2(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          O2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const a = JSON.stringify(s);
      o.send(e, "POST", a, n, 15);
    });
  }
  co(t2, e, n) {
    const s = [this.no, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.oo(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const a = s.join("");
    O2("Connection", "Creating WebChannel: " + a, o);
    const u = i.createWebChannel(a, o);
    let c = false, h = false;
    const l2 = new xo({
      Qr: (t3) => {
        h ? O2("Connection", "Not sending because WebChannel is closed:", t3) : (c || (O2("Connection", "Opening WebChannel transport."), u.open(), c = true), O2("Connection", "WebChannel sending:", t3), u.send(t3));
      },
      jr: () => u.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(u, WebChannel.EventType.OPEN, () => {
      h || O2("Connection", "WebChannel transport opened.");
    }), y2(u, WebChannel.EventType.CLOSE, () => {
      h || (h = true, O2("Connection", "WebChannel transport closed"), l2.Zr());
    }), y2(u, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, F2("Connection", "WebChannel transport errored:", t3), l2.Zr(new Q2(G.UNAVAILABLE, "The operation could not be completed")));
    }), y2(u, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        q2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          O2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = Pn[t5];
            if (e4 !== void 0)
              return Sn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = G.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.Zr(new Q2(e3, n3)), u.close();
        } else
          O2("Connection", "WebChannel received:", n2), l2.eo(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? O2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && O2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.Xr();
    }, 0), l2;
  }
};
function ko() {
  return typeof window != "undefined" ? window : null;
}
function Mo() {
  return typeof document != "undefined" ? document : null;
}
function Oo(t2) {
  return new is(t2, true);
}
var $o = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Hn = t2, this.timerId = e, this.ho = n, this.lo = s, this.fo = i, this._o = 0, this.wo = null, this.mo = Date.now(), this.reset();
  }
  reset() {
    this._o = 0;
  }
  yo() {
    this._o = this.fo;
  }
  po(t2) {
    this.cancel();
    const e = Math.floor(this._o + this.Io()), n = Math.max(0, Date.now() - this.mo), s = Math.max(0, e - n);
    s > 0 && O2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this._o} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.wo = this.Hn.enqueueAfterDelay(this.timerId, s, () => (this.mo = Date.now(), t2())), this._o *= this.lo, this._o < this.ho && (this._o = this.ho), this._o > this.fo && (this._o = this.fo);
  }
  To() {
    this.wo !== null && (this.wo.skipDelay(), this.wo = null);
  }
  cancel() {
    this.wo !== null && (this.wo.cancel(), this.wo = null);
  }
  Io() {
    return (Math.random() - 0.5) * this._o;
  }
};
var Fo = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.Hn = t2, this.Eo = n, this.Ao = s, this.Ro = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = a, this.state = 0, this.bo = 0, this.Po = null, this.Vo = null, this.stream = null, this.vo = new $o(t2, e);
  }
  So() {
    return this.state === 1 || this.state === 5 || this.Do();
  }
  Do() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.Co();
  }
  async stop() {
    this.So() && await this.close(0);
  }
  xo() {
    this.state = 0, this.vo.reset();
  }
  No() {
    this.Do() && this.Po === null && (this.Po = this.Hn.enqueueAfterDelay(this.Eo, 6e4, () => this.ko()));
  }
  Mo(t2) {
    this.Oo(), this.stream.send(t2);
  }
  async ko() {
    if (this.Do())
      return this.close(0);
  }
  Oo() {
    this.Po && (this.Po.cancel(), this.Po = null);
  }
  $o() {
    this.Vo && (this.Vo.cancel(), this.Vo = null);
  }
  async close(t2, e) {
    this.Oo(), this.$o(), this.vo.cancel(), this.bo++, t2 !== 4 ? this.vo.reset() : e && e.code === G.RESOURCE_EXHAUSTED ? ($(e.toString()), $("Using maximum backoff delay to prevent overloading the backend."), this.vo.yo()) : e && e.code === G.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Fo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Hr(e);
  }
  Fo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Bo(this.bo), e = this.bo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.bo === e && this.Lo(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new Q2(G.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.qo(t3);
      });
    });
  }
  Lo(t2, e) {
    const n = this.Bo(this.bo);
    this.stream = this.Uo(t2, e), this.stream.Wr(() => {
      n(() => (this.state = 2, this.Vo = this.Hn.enqueueAfterDelay(this.Ao, 1e4, () => (this.Do() && (this.state = 3), Promise.resolve())), this.listener.Wr()));
    }), this.stream.Hr((t3) => {
      n(() => this.qo(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  Co() {
    this.state = 5, this.vo.po(async () => {
      this.state = 0, this.start();
    });
  }
  qo(t2) {
    return O2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Bo(t2) {
    return (e) => {
      this.Hn.enqueueAndForget(() => this.bo === t2 ? e() : (O2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var Bo = class extends Fo {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.M = i;
  }
  Uo(t2, e) {
    return this.Ro.co("Listen", t2, e);
  }
  onMessage(t2) {
    this.vo.reset();
    const e = Is(this.M, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? us(e2.readTime) : ct.min();
    }(t2);
    return this.listener.Ko(e, n);
  }
  Go(t2) {
    const e = {};
    e.database = ws(this.M), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = fe(s) ? {
        documents: Rs(t3, s)
      } : {
        query: bs(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = os(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = rs(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.M, t2);
    const n = Vs(this.M, t2);
    n && (e.labels = n), this.Mo(e);
  }
  Qo(t2) {
    const e = {};
    e.database = ws(this.M), e.removeTarget = t2, this.Mo(e);
  }
};
var Lo = class extends Fo {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.M = i, this.jo = false;
  }
  get Wo() {
    return this.jo;
  }
  start() {
    this.jo = false, this.lastStreamToken = void 0, super.start();
  }
  Fo() {
    this.jo && this.zo([]);
  }
  Uo(t2, e) {
    return this.Ro.co("Write", t2, e);
  }
  onMessage(t2) {
    if (q2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.jo) {
      this.vo.reset();
      const e = As(t2.writeResults, t2.commitTime), n = us(t2.commitTime);
      return this.listener.Ho(n, e);
    }
    return q2(!t2.writeResults || t2.writeResults.length === 0), this.jo = true, this.listener.Jo();
  }
  Yo() {
    const t2 = {};
    t2.database = ws(this.M), this.Mo(t2);
  }
  zo(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => Ts(this.M, t3))
    };
    this.Mo(e);
  }
};
var qo = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.Ro = n, this.M = s, this.Xo = false;
  }
  Zo() {
    if (this.Xo)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  io(t2, e, n) {
    return this.Zo(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.Ro.io(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  uo(t2, e, n) {
    return this.Zo(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.Ro.uo(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(G.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Xo = true;
  }
};
var Uo = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.ta = 0, this.ea = null, this.na = true;
  }
  sa() {
    this.ta === 0 && (this.ia("Unknown"), this.ea = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ea = null, this.ra("Backend didn't respond within 10 seconds."), this.ia("Offline"), Promise.resolve())));
  }
  oa(t2) {
    this.state === "Online" ? this.ia("Unknown") : (this.ta++, this.ta >= 1 && (this.aa(), this.ra(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.ia("Offline")));
  }
  set(t2) {
    this.aa(), this.ta = 0, t2 === "Online" && (this.na = false), this.ia(t2);
  }
  ia(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  ra(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.na ? ($(e), this.na = false) : O2("OnlineStateTracker", e);
  }
  aa() {
    this.ea !== null && (this.ea.cancel(), this.ea = null);
  }
};
var Ko = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.ua = [], this.ca = /* @__PURE__ */ new Map(), this.ha = /* @__PURE__ */ new Set(), this.la = [], this.fa = i, this.fa.Fr((t3) => {
      n.enqueueAndForget(async () => {
        Xo(this) && (O2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = K2(t4);
          e2.ha.add(4), await Qo(e2), e2.da.set("Unknown"), e2.ha.delete(4), await Go(e2);
        }(this));
      });
    }), this.da = new Uo(n, s);
  }
};
async function Go(t2) {
  if (Xo(t2))
    for (const e of t2.la)
      await e(true);
}
async function Qo(t2) {
  for (const e of t2.la)
    await e(false);
}
function jo(t2, e) {
  const n = K2(t2);
  n.ca.has(e.targetId) || (n.ca.set(e.targetId, e), Yo(n) ? Jo(n) : ma2(n).Do() && zo(n, e));
}
function Wo(t2, e) {
  const n = K2(t2), s = ma2(n);
  n.ca.delete(e), s.Do() && Ho(n, e), n.ca.size === 0 && (s.Do() ? s.No() : Xo(n) && n.da.set("Unknown"));
}
function zo(t2, e) {
  t2._a.Z(e.targetId), ma2(t2).Go(e);
}
function Ho(t2, e) {
  t2._a.Z(e), ma2(t2).Qo(e);
}
function Jo(t2) {
  t2._a = new Zn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.ca.get(e) || null
  }), ma2(t2).start(), t2.da.sa();
}
function Yo(t2) {
  return Xo(t2) && !ma2(t2).So() && t2.ca.size > 0;
}
function Xo(t2) {
  return K2(t2).ha.size === 0;
}
function Zo(t2) {
  t2._a = void 0;
}
async function ta2(t2) {
  t2.ca.forEach((e, n) => {
    zo(t2, e);
  });
}
async function ea2(t2, e) {
  Zo(t2), Yo(t2) ? (t2.da.oa(e), Jo(t2)) : t2.da.set("Unknown");
}
async function na2(t2, e, n) {
  if (t2.da.set("Online"), e instanceof Yn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.ca.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.ca.delete(s), t3._a.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      O2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await sa2(t2, n2);
    }
  else if (e instanceof Hn ? t2._a.at(e) : e instanceof Jn ? t2._a._t(e) : t2._a.ht(e), !n.isEqual(ct.min()))
    try {
      const e2 = await Hr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3._a.yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.ca.get(s);
            i && t3.ca.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.ca.get(e4);
          if (!n3)
            return;
          t3.ca.set(e4, n3.withResumeToken(pt.EMPTY_BYTE_STRING, n3.snapshotVersion)), Ho(t3, e4);
          const s = new Ai(n3.target, e4, 1, n3.sequenceNumber);
          zo(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      O2("RemoteStore", "Failed to raise snapshot:", e2), await sa2(t2, e2);
    }
}
async function sa2(t2, e, n) {
  if (!di(e))
    throw e;
  t2.ha.add(1), await Qo(t2), t2.da.set("Offline"), n || (n = () => Hr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    O2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.ha.delete(1), await Go(t2);
  });
}
function ia2(t2, e) {
  return e().catch((n) => sa2(t2, n, e));
}
async function ra2(t2) {
  const e = K2(t2), n = ga(e);
  let s = e.ua.length > 0 ? e.ua[e.ua.length - 1].batchId : -1;
  for (; oa2(e); )
    try {
      const t3 = await Xr(e.localStore, s);
      if (t3 === null) {
        e.ua.length === 0 && n.No();
        break;
      }
      s = t3.batchId, aa2(e, t3);
    } catch (t3) {
      await sa2(e, t3);
    }
  ua2(e) && ca(e);
}
function oa2(t2) {
  return Xo(t2) && t2.ua.length < 10;
}
function aa2(t2, e) {
  t2.ua.push(e);
  const n = ga(t2);
  n.Do() && n.Wo && n.zo(e.mutations);
}
function ua2(t2) {
  return Xo(t2) && !ga(t2).So() && t2.ua.length > 0;
}
function ca(t2) {
  ga(t2).start();
}
async function ha2(t2) {
  ga(t2).Yo();
}
async function la2(t2) {
  const e = ga(t2);
  for (const n of t2.ua)
    e.zo(n.mutations);
}
async function fa2(t2, e, n) {
  const s = t2.ua.shift(), i = Ti.from(s, e, n);
  await ia2(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await ra2(t2);
}
async function da2(t2, e) {
  e && ga(t2).Wo && await async function(t3, e2) {
    if (n = e2.code, vn(n) && n !== G.ABORTED) {
      const n2 = t3.ua.shift();
      ga(t3).xo(), await ia2(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await ra2(t3);
    }
    var n;
  }(t2, e), ua2(t2) && ca(t2);
}
async function _a(t2, e) {
  const n = K2(t2);
  n.asyncQueue.verifyOperationInProgress(), O2("RemoteStore", "RemoteStore received new credentials");
  const s = Xo(n);
  n.ha.add(3), await Qo(n), s && n.da.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.ha.delete(3), await Go(n);
}
async function wa(t2, e) {
  const n = K2(t2);
  e ? (n.ha.delete(2), await Go(n)) : e || (n.ha.add(2), await Qo(n), n.da.set("Unknown"));
}
function ma2(t2) {
  return t2.wa || (t2.wa = function(t3, e, n) {
    const s = K2(t3);
    return s.Zo(), new Bo(e, s.Ro, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    Wr: ta2.bind(null, t2),
    Hr: ea2.bind(null, t2),
    Ko: na2.bind(null, t2)
  }), t2.la.push(async (e) => {
    e ? (t2.wa.xo(), Yo(t2) ? Jo(t2) : t2.da.set("Unknown")) : (await t2.wa.stop(), Zo(t2));
  })), t2.wa;
}
function ga(t2) {
  return t2.ma || (t2.ma = function(t3, e, n) {
    const s = K2(t3);
    return s.Zo(), new Lo(e, s.Ro, s.authCredentials, s.appCheckCredentials, s.M, n);
  }(t2.datastore, t2.asyncQueue, {
    Wr: ha2.bind(null, t2),
    Hr: da2.bind(null, t2),
    Jo: la2.bind(null, t2),
    Ho: fa2.bind(null, t2)
  }), t2.la.push(async (e) => {
    e ? (t2.ma.xo(), await ra2(t2)) : (await t2.ma.stop(), t2.ua.length > 0 && (O2("RemoteStore", `Stopping write stream with ${t2.ua.length} pending writes`), t2.ua = []));
  })), t2.ma;
}
var ya2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new ya2(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Q2(G.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function pa2(t2, e) {
  if ($("AsyncQueue", `${e}: ${t2}`), di(t2))
    return new Q2(G.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Ia2 = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || xt.comparator(e.key, n.key) : (t3, e) => xt.comparator(t3.key, e.key), this.keyedMap = Ln(), this.sortedSet = new Cn(this.comparator);
  }
  static emptySet(t2) {
    return new Ia2(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Ia2))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Ia2();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Ta = class {
  constructor() {
    this.ga = new Cn(xt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.ga.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.ga = this.ga.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.ga = this.ga.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.ga = this.ga.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.ga = this.ga.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.ga = this.ga.remove(e) : t2.type === 1 && n.type === 2 ? this.ga = this.ga.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.ga = this.ga.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.ga = this.ga.insert(e, t2);
  }
  ya() {
    const t2 = [];
    return this.ga.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Ea = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = a;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Ea(t2, e, Ia2.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Be(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Aa2 = class {
  constructor() {
    this.pa = void 0, this.listeners = [];
  }
};
var Ra2 = class {
  constructor() {
    this.queries = new Dn((t2) => Le(t2), Be), this.onlineState = "Unknown", this.Ia = /* @__PURE__ */ new Set();
  }
};
async function ba2(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Aa2()), i)
    try {
      r.pa = await n.onListen(s);
    } catch (t3) {
      const n2 = pa2(t3, `Initialization of query '${qe(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Ta(n.onlineState), r.pa) {
    e.Ea(r.pa) && Sa2(n);
  }
}
async function Pa(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Va2(t2, e) {
  const n = K2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Ea(t3) && (s = true);
      i.pa = t3;
    }
  }
  s && Sa2(n);
}
function va(t2, e, n) {
  const s = K2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Sa2(t2) {
  t2.Ia.forEach((t3) => {
    t3.next();
  });
}
var Da = class {
  constructor(t2, e, n) {
    this.query = t2, this.Aa = e, this.Ra = false, this.ba = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Ea(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Ea(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.Ra ? this.Pa(t2) && (this.Aa.next(t2), e = true) : this.Va(t2, this.onlineState) && (this.va(t2), e = true), this.ba = t2, e;
  }
  onError(t2) {
    this.Aa.error(t2);
  }
  Ta(t2) {
    this.onlineState = t2;
    let e = false;
    return this.ba && !this.Ra && this.Va(this.ba, t2) && (this.va(this.ba), e = true), e;
  }
  Va(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.Sa || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  Pa(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.ba && this.ba.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  va(t2) {
    t2 = Ea.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.Ra = true, this.Aa.next(t2);
  }
};
var Ca2 = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  Da() {
    return "metadata" in this.payload;
  }
};
var xa2 = class {
  constructor(t2) {
    this.M = t2;
  }
  li(t2) {
    return fs(this.M, t2);
  }
  fi(t2) {
    return t2.metadata.exists ? ys(this.M, t2.document, false) : te.newNoDocument(this.li(t2.metadata.name), this.di(t2.metadata.readTime));
  }
  di(t2) {
    return us(t2);
  }
};
var Na2 = class {
  constructor(t2, e, n) {
    this.Ca = t2, this.localStore = e, this.M = n, this.queries = [], this.documents = [], this.progress = ka2(t2);
  }
  xa(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  Na(t2) {
    const e = /* @__PURE__ */ new Map(), n = new xa2(this.M);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.li(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Gn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await ro(this.localStore, new xa2(this.M), this.documents, this.Ca.id), e = this.Na(this.documents);
    for (const t3 of this.queries)
      await oo(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new qr(Object.assign({}, this.progress), t2);
  }
};
function ka2(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Ma2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Oa = class {
  constructor(t2) {
    this.key = t2;
  }
};
var $a2 = class {
  constructor(t2, e) {
    this.query = t2, this.ka = e, this.Ma = null, this.current = false, this.Oa = Gn(), this.mutatedKeys = Gn(), this.$a = Ke(t2), this.Fa = new Ia2(this.$a);
  }
  get Ba() {
    return this.ka;
  }
  La(t2, e) {
    const n = e ? e.qa : new Ta(), s = e ? e.Fa : this.Fa;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const a = Ce(this.query) && s.size === this.query.limit ? s.last() : null, u = xe(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const c = s.get(t3), h = Ue(this.query, e2) ? e2 : null, l2 = !!c && this.mutatedKeys.has(c.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (c && h) {
        c.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Ua(c, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (a && this.$a(h, a) > 0 || u && this.$a(h, u) < 0) && (o = true));
      } else
        !c && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : c && !h && (n.track({
          type: 1,
          doc: c
        }), d = true, (a || u) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), Ce(this.query) || xe(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = Ce(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Fa: r,
      qa: n,
      ei: o,
      mutatedKeys: i
    };
  }
  Ua(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Fa;
    this.Fa = t2.Fa, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.qa.ya();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.$a(t3.doc, e2.doc)), this.Ka(n);
    const r = e ? this.Ga() : [], o = this.Oa.size === 0 && this.current ? 1 : 0, a = o !== this.Ma;
    if (this.Ma = o, i.length !== 0 || a) {
      return {
        snapshot: new Ea(this.query, t2.Fa, s, i, t2.mutatedKeys, o === 0, a, false),
        Qa: r
      };
    }
    return {
      Qa: r
    };
  }
  Ta(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Fa: this.Fa,
      qa: new Ta(),
      mutatedKeys: this.mutatedKeys,
      ei: false
    }, false)) : {
      Qa: []
    };
  }
  ja(t2) {
    return !this.ka.has(t2) && (!!this.Fa.has(t2) && !this.Fa.get(t2).hasLocalMutations);
  }
  Ka(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.ka = this.ka.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.ka = this.ka.delete(t3)), this.current = t2.current);
  }
  Ga() {
    if (!this.current)
      return [];
    const t2 = this.Oa;
    this.Oa = Gn(), this.Fa.forEach((t3) => {
      this.ja(t3.key) && (this.Oa = this.Oa.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Oa.has(t3) || e.push(new Oa(t3));
    }), this.Oa.forEach((n) => {
      t2.has(n) || e.push(new Ma2(n));
    }), e;
  }
  Wa(t2) {
    this.ka = t2.hi, this.Oa = Gn();
    const e = this.La(t2.documents);
    return this.applyChanges(e, true);
  }
  za() {
    return Ea.fromInitialDocuments(this.query, this.Fa, this.mutatedKeys, this.Ma === 0);
  }
};
var Fa2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var Ba = class {
  constructor(t2) {
    this.key = t2, this.Ha = false;
  }
};
var La2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Ja = {}, this.Ya = new Dn((t3) => Le(t3), Be), this.Xa = /* @__PURE__ */ new Map(), this.Za = /* @__PURE__ */ new Set(), this.tu = new Cn(xt.comparator), this.eu = /* @__PURE__ */ new Map(), this.nu = new co(), this.su = {}, this.iu = /* @__PURE__ */ new Map(), this.ru = mr.gn(), this.onlineState = "Unknown", this.ou = void 0;
  }
  get isPrimaryClient() {
    return this.ou === true;
  }
};
async function qa2(t2, e) {
  const n = mu(t2);
  let s, i;
  const r = n.Ya.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.za();
  else {
    const t3 = await Zr(n.localStore, $e(e));
    n.isPrimaryClient && jo(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Ua2(n, e, s, r2 === "current");
  }
  return i;
}
async function Ua2(t2, e, n, s) {
  t2.au = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.La(n3);
    i2.ei && (i2 = await eo(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.La(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return eu(t3, e3.targetId, o2.Qa), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await eo(t2.localStore, e, true), r = new $a2(e, i.hi), o = r.La(i.documents), a = zn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), u = r.applyChanges(o, t2.isPrimaryClient, a);
  eu(t2, n, u.Qa);
  const c = new Fa2(e, n, r);
  return t2.Ya.set(e, c), t2.Xa.has(n) ? t2.Xa.get(n).push(e) : t2.Xa.set(n, [e]), u.snapshot;
}
async function Ka2(t2, e) {
  const n = K2(t2), s = n.Ya.get(e), i = n.Xa.get(s.targetId);
  if (i.length > 1)
    return n.Xa.set(s.targetId, i.filter((t3) => !Be(t3, e))), void n.Ya.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await to(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), Wo(n.remoteStore, s.targetId), Za2(n, s.targetId);
    }).catch(Tr);
  } else
    Za2(n, s.targetId), await to(n.localStore, s.targetId, true);
}
async function Ga2(t2, e, n) {
  const s = gu(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4), s2 = ut.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Gn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.ui.Us(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = wn(t6, r.get(t6.key));
          e3 != null && o.push(new pn(t6.key, e3, Zt(e3.value.mapValue), hn.exists(true)));
        }
        return n2.Fs.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.su[t4.currentUser.toKey()];
      s2 || (s2 = new Cn(rt));
      s2 = s2.insert(e2, n2), t4.su[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await iu(s, t3.changes), await ra2(s.remoteStore);
  } catch (t3) {
    const e2 = pa2(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function Qa(t2, e) {
  const n = K2(t2);
  try {
    const t3 = await Jr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.eu.get(e2);
      s && (q2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Ha = true : t4.modifiedDocuments.size > 0 ? q2(s.Ha) : t4.removedDocuments.size > 0 && (q2(s.Ha), s.Ha = false));
    }), await iu(n, t3, e);
  } catch (t3) {
    await Tr(t3);
  }
}
function ja2(t2, e, n) {
  const s = K2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.Ya.forEach((n2, s2) => {
      const i = s2.view.Ta(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = K2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.Ta(e2) && (s2 = true);
      }), s2 && Sa2(n2);
    }(s.eventManager, e), t3.length && s.Ja.Ko(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function Wa2(t2, e, n) {
  const s = K2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.eu.get(e), r = i && i.key;
  if (r) {
    let t3 = new Cn(xt.comparator);
    t3 = t3.insert(r, te.newNoDocument(r, ct.min()));
    const n2 = Gn().add(r), i2 = new Wn(ct.min(), /* @__PURE__ */ new Map(), new kn(rt), t3, n2);
    await Qa(s, i2), s.tu = s.tu.remove(r), s.eu.delete(e), su(s);
  } else
    await to(s.localStore, e, false).then(() => Za2(s, e, n)).catch(Tr);
}
async function za2(t2, e) {
  const n = K2(t2), s = e.batch.batchId;
  try {
    const t3 = await zr(n.localStore, e);
    Xa2(n, s, null), Ya2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await iu(n, t3);
  } catch (t3) {
    await Tr(t3);
  }
}
async function Ha2(t2, e, n) {
  const s = K2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.Fs.lookupMutationBatch(t5, e2).next((e3) => (q2(e3 !== null), s2 = e3.keys(), n2.Fs.removeMutationBatch(t5, e3))).next(() => n2.Fs.performConsistencyCheck(t5)).next(() => n2.ui.Us(t5, s2));
      });
    }(s.localStore, e);
    Xa2(s, e, n), Ya2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await iu(s, t3);
  } catch (n2) {
    await Tr(n2);
  }
}
async function Ja2(t2, e) {
  const n = K2(t2);
  Xo(n.remoteStore) || O2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = K2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.Fs.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.iu.get(t3) || [];
    s.push(e), n.iu.set(t3, s);
  } catch (t3) {
    const n2 = pa2(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function Ya2(t2, e) {
  (t2.iu.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.iu.delete(e);
}
function Xa2(t2, e, n) {
  const s = K2(t2);
  let i = s.su[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.su[s.currentUser.toKey()] = i;
  }
}
function Za2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Xa.get(e))
    t2.Ya.delete(s), n && t2.Ja.uu(s, n);
  if (t2.Xa.delete(e), t2.isPrimaryClient) {
    t2.nu.Ri(e).forEach((e2) => {
      t2.nu.containsKey(e2) || tu(t2, e2);
    });
  }
}
function tu(t2, e) {
  t2.Za.delete(e.path.canonicalString());
  const n = t2.tu.get(e);
  n !== null && (Wo(t2.remoteStore, n), t2.tu = t2.tu.remove(e), t2.eu.delete(n), su(t2));
}
function eu(t2, e, n) {
  for (const s of n)
    if (s instanceof Ma2)
      t2.nu.addReference(s.key, e), nu(t2, s);
    else if (s instanceof Oa) {
      O2("SyncEngine", "Document no longer in limbo: " + s.key), t2.nu.removeReference(s.key, e);
      t2.nu.containsKey(s.key) || tu(t2, s.key);
    } else
      L2();
}
function nu(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.tu.get(n) || t2.Za.has(s) || (O2("SyncEngine", "New document in limbo: " + n), t2.Za.add(s), su(t2));
}
function su(t2) {
  for (; t2.Za.size > 0 && t2.tu.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.Za.values().next().value;
    t2.Za.delete(e);
    const n = new xt(_t.fromString(e)), s = t2.ru.next();
    t2.eu.set(s, new Ba(n)), t2.tu = t2.tu.insert(n, s), jo(t2.remoteStore, new Ai($e(De(n.path)), s, 2, nt.A));
  }
}
async function iu(t2, e, n) {
  const s = K2(t2), i = [], r = [], o = [];
  s.Ya.isEmpty() || (s.Ya.forEach((t3, a) => {
    o.push(s.au(a, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(a.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = Kr.Js(a.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Ja.Ko(i), await async function(t3, e2) {
    const n2 = K2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => ui.forEach(e2, (e3) => ui.forEach(e3.zs, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => ui.forEach(e3.Hs, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!di(t4))
        throw t4;
      O2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.si.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.si = n2.si.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function ru(t2, e) {
  const n = K2(t2);
  if (!n.currentUser.isEqual(e)) {
    O2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await Wr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.iu.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q2(G.CANCELLED, e2));
        });
      }), t4.iu.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await iu(n, t3.ci);
  }
}
function ou(t2, e) {
  const n = K2(t2), s = n.eu.get(e);
  if (s && s.Ha)
    return Gn().add(s.key);
  {
    let t3 = Gn();
    const s2 = n.Xa.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.Ya.get(e2);
      t3 = t3.unionWith(s3.view.Ba);
    }
    return t3;
  }
}
async function au(t2, e) {
  const n = K2(t2), s = await eo(n.localStore, e.query, true), i = e.view.Wa(s);
  return n.isPrimaryClient && eu(n, e.targetId, i.Qa), i;
}
async function uu(t2) {
  const e = K2(t2);
  return so(e.localStore).then((t3) => iu(e, t3));
}
async function cu(t2, e, n, s) {
  const i = K2(t2), r = await function(t3, e2) {
    const n2 = K2(t3), s2 = K2(n2.Fs);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.ln(t4, e2).next((e3) => e3 ? n2.ui.Us(t4, e3) : ui.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await ra2(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (Xa2(i, e, s || null), Ya2(i, e), function(t3, e2) {
    K2(K2(t3).Fs).dn(e2);
  }(i.localStore, e)) : L2(), await iu(i, r)) : O2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function hu(t2, e) {
  const n = K2(t2);
  if (mu(n), gu(n), e === true && n.ou !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await lu(n, t3.toArray());
    n.ou = true, await wa(n.remoteStore, true);
    for (const t4 of e2)
      jo(n.remoteStore, t4);
  } else if (e === false && n.ou !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.Xa.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (Za2(n, i), to(n.localStore, i, true))), Wo(n.remoteStore, i);
    }), await e2, await lu(n, t3), function(t4) {
      const e3 = K2(t4);
      e3.eu.forEach((t5, n2) => {
        Wo(e3.remoteStore, n2);
      }), e3.nu.bi(), e3.eu = /* @__PURE__ */ new Map(), e3.tu = new Cn(xt.comparator);
    }(n), n.ou = false, await wa(n.remoteStore, false);
  }
}
async function lu(t2, e, n) {
  const s = K2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.Xa.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await Zr(s.localStore, $e(n2[0]));
      for (const t4 of n2) {
        const e3 = s.Ya.get(t4), n3 = await au(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await no(s.localStore, t3);
      e2 = await Zr(s.localStore, n3), await Ua2(s, fu(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Ja.Ko(r), i;
}
function fu(t2) {
  return Se(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function du(t2) {
  const e = K2(t2);
  return K2(K2(e.localStore).persistence).Ms();
}
async function _u(t2, e, n, s) {
  const i = K2(t2);
  if (i.ou)
    O2("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Xa.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await so(i.localStore), s2 = Wn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await iu(i, t3, s2);
        break;
      }
      case "rejected":
        await to(i.localStore, e, true), Za2(i, e, s);
        break;
      default:
        L2();
    }
}
async function wu(t2, e, n) {
  const s = mu(t2);
  if (s.ou) {
    for (const t3 of e) {
      if (s.Xa.has(t3)) {
        O2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await no(s.localStore, t3), n2 = await Zr(s.localStore, e2);
      await Ua2(s, fu(e2), n2.targetId, false), jo(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.Xa.has(t3) && await to(s.localStore, t3, false).then(() => {
        Wo(s.remoteStore, t3), Za2(s, t3);
      }).catch(Tr);
  }
}
function mu(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Qa.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = ou.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Wa2.bind(null, e), e.Ja.Ko = Va2.bind(null, e.eventManager), e.Ja.uu = va.bind(null, e.eventManager), e;
}
function gu(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = za2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = Ha2.bind(null, e), e;
}
function yu(t2, e, n) {
  const s = K2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = K2(t4), s3 = us(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.fs.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(ka2(s2));
      const i = new Na2(s2, t3.localStore, e2.M);
      let r = await e2.cu();
      for (; r; ) {
        const t4 = await i.xa(r);
        t4 && n2._updateProgress(t4), r = await e2.cu();
      }
      const o = await i.complete();
      await iu(t3, o.$s, void 0), await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.fs.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      F2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var pu = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.M = Oo(t2.databaseInfo.databaseId), this.sharedClientState = this.hu(t2), this.persistence = this.lu(t2), await this.persistence.start(), this.gcScheduler = this.fu(t2), this.localStore = this.du(t2);
  }
  fu(t2) {
    return null;
  }
  du(t2) {
    return jr(this.persistence, new Gr(), t2.initialUser, this.M);
  }
  lu(t2) {
    return new mo(yo.Wi, this.M);
  }
  hu(t2) {
    return new vo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Iu = class extends pu {
  constructor(t2, e, n) {
    super(), this._u = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await io(this.localStore), await this._u.initialize(this, t2), await gu(this._u.syncEngine), await ra2(this._u.remoteStore), await this.persistence.ps(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  du(t2) {
    return jr(this.persistence, new Gr(), t2.initialUser, this.M);
  }
  fu(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Rr(e, t2.asyncQueue);
  }
  lu(t2) {
    const e = Lr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? ur.withCacheSize(this.cacheSizeBytes) : ur.DEFAULT;
    return new $r(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, ko(), Mo(), this.M, this.sharedClientState, !!this.forceOwnership);
  }
  hu(t2) {
    return new vo();
  }
};
var Tu = class extends Iu {
  constructor(t2, e) {
    super(t2, e, false), this._u = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this._u.syncEngine;
    this.sharedClientState instanceof Vo && (this.sharedClientState.syncEngine = {
      Nr: cu.bind(null, e),
      kr: _u.bind(null, e),
      Mr: wu.bind(null, e),
      Ms: du.bind(null, e),
      Cr: uu.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.ps(async (t3) => {
      await hu(this._u.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  hu(t2) {
    const e = ko();
    if (!Vo.vt(e))
      throw new Q2(G.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Lr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Vo(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Eu = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => ja2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = ru.bind(null, this.syncEngine), await wa(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Ra2();
  }
  createDatastore(t2) {
    const e = Oo(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new No(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new qo(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => ja2(this.syncEngine, t3, 0), r = Do.vt() ? new Do() : new So(), new Ko(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const a = new La2(t3, e2, n, s, i, r);
      return o && (a.ou = true), a;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = K2(t2);
      O2("RemoteStore", "RemoteStore shutting down."), e.ha.add(5), await Qo(e), e.fa.shutdown(), e.da.set("Unknown");
    }(this.remoteStore);
  }
};
function Au(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Ru = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.wu(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.wu(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  mu() {
    this.muted = true;
  }
  wu(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var bu = class {
  constructor(t2, e) {
    this.gu = t2, this.M = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.yu = new TextDecoder("utf-8"), this.pu().then((t3) => {
      t3 && t3.Da() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.gu.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async cu() {
    return await this.getMetadata(), this.pu();
  }
  async pu() {
    const t2 = await this.Iu();
    if (t2 === null)
      return null;
    const e = this.yu.decode(t2), n = Number(e);
    isNaN(n) && this.Tu(`length string (${e}) is not valid number`);
    const s = await this.Eu(n);
    return new Ca2(JSON.parse(s), t2.length + n);
  }
  Au() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Iu() {
    for (; this.Au() < 0; ) {
      if (await this.Ru())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.Au();
    t2 < 0 && this.Tu("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async Eu(t2) {
    for (; this.buffer.length < t2; ) {
      await this.Ru() && this.Tu("Reached the end of bundle when more is expected.");
    }
    const e = this.yu.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Tu(t2) {
    throw this.gu.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async Ru() {
    const t2 = await this.gu.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Pu = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q2(G.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = K2(t3), s = ws(n.M) + "/documents", i = {
        documents: e2.map((t4) => ls(n.M, t4))
      }, r = await n.uo("BatchGetDocuments", s, i), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = ps(n.M, t4);
        o.set(e3.key.toString(), e3);
      });
      const a = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        q2(!!e3), a.push(e3);
      }), a;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new An(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = xt.fromPath(e);
      this.mutations.push(new Rn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = K2(t3), s = ws(n.M) + "/documents", i = {
        writes: e.map((t4) => Ts(n.M, t4))
      };
      await n.io("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = ct.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q2(G.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? hn.updateTime(e) : hn.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new Q2(G.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return hn.updateTime(e);
    }
    return hn.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Vu = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.bu = 5, this.vo = new $o(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.bu -= 1, this.Pu();
  }
  Pu() {
    this.vo.po(async () => {
      const t2 = new Pu(this.datastore), e = this.Vu(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.vu(t3);
        }));
      }).catch((t3) => {
        this.vu(t3);
      });
    });
  }
  Vu(t2) {
    try {
      const e = this.updateFunction(t2);
      return !St(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  vu(t2) {
    this.bu > 0 && this.Su(t2) ? (this.bu -= 1, this.asyncQueue.enqueueAndForget(() => (this.Pu(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  Su(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !vn(e);
    }
    return false;
  }
};
var vu = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = it.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      O2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (O2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q2(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = pa2(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Su(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), O2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await Wr(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Du(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Cu(t2);
  O2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => _a(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => _a(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function Cu(t2) {
  return t2.offlineComponents || (O2("FirestoreClient", "Using default OfflineComponentProvider"), await Su(t2, new pu())), t2.offlineComponents;
}
async function xu(t2) {
  return t2.onlineComponents || (O2("FirestoreClient", "Using default OnlineComponentProvider"), await Du(t2, new Eu())), t2.onlineComponents;
}
function Nu(t2) {
  return Cu(t2).then((t3) => t3.persistence);
}
function ku(t2) {
  return Cu(t2).then((t3) => t3.localStore);
}
function Mu(t2) {
  return xu(t2).then((t3) => t3.remoteStore);
}
function Ou(t2) {
  return xu(t2).then((t3) => t3.syncEngine);
}
async function $u(t2) {
  const e = await xu(t2), n = e.eventManager;
  return n.onListen = qa2.bind(null, e.syncEngine), n.onUnlisten = Ka2.bind(null, e.syncEngine), n;
}
function Fu(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Nu(t2), n = await Mu(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = K2(t3);
      return e2.ha.delete(0), Go(e2);
    }(n);
  });
}
function Bu(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Nu(t2), n = await Mu(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = K2(t3);
      e2.ha.add(0), await Qo(e2), e2.da.set("Offline");
    }(n);
  });
}
function Lu(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.ui.Bs(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q2(G.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = pa2(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await ku(t2), e, n)), n.promise;
}
function qu(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ru({
      next: (r2) => {
        e2.enqueueAndForget(() => Pa(t3, o));
        const a = r2.docs.has(n2);
        !a && r2.fromCache ? i.reject(new Q2(G.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && r2.fromCache && s2 && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Da(De(n2.path), r, {
      includeMetadataChanges: true,
      Sa: true
    });
    return ba2(t3, o);
  }(await $u(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Uu(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await eo(t3, e2, true), i = new $a2(e2, s.hi), r = i.La(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = pa2(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await ku(t2), e, n)), n.promise;
}
function Ku(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ru({
      next: (n3) => {
        e2.enqueueAndForget(() => Pa(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new Q2(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Da(n2, r, {
      includeMetadataChanges: true,
      Sa: true
    });
    return ba2(t3, o);
  }(await $u(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Gu(t2, e) {
  const n = new Ru(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    K2(t3).Ia.add(e2), e2.next();
  }(await $u(t2), n)), () => {
    n.mu(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      K2(t3).Ia.delete(e2);
    }(await $u(t2), n));
  };
}
function Qu(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return xu(t3).then((t4) => t4.datastore);
    }(t2);
    new Vu(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function ju(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new bu(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Au(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Au(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Oo(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    yu(await Ou(t2), i, s);
  });
}
function Wu(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = K2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.fs.getNamedQuery(t4, e2));
  }(await ku(t2), e));
}
var zu = /* @__PURE__ */ new Map();
function Hu(t2, e, n) {
  if (!n)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function Ju(t2, e, n, s) {
  if (e === true && s === true)
    throw new Q2(G.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function Yu(t2) {
  if (!xt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function Xu(t2) {
  if (xt.isDocumentKey(t2))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function Zu(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function tc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new Q2(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = Zu(t2);
      throw new Q2(G.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function ec2(t2, e) {
  if (e <= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var nc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new Q2(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new Q2(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, Ju("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var sc2 = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new nc2({}), this._settingsFrozen = false, t2 instanceof vt ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q2(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new vt(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new nc2(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return q2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q2(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = zu.get(t2);
      e && (O2("ComponentProvider", "Removing Datastore"), zu.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function ic2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = tc2(t2, sc2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && F2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q2(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new W2(e2, n2));
  }
}
var rc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new ac2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new rc2(this.firestore, t2, this._key);
  }
};
var oc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new oc2(this.firestore, t2, this._query);
  }
};
var ac2 = class extends oc2 {
  constructor(t2, e, n) {
    super(t2, e, De(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new rc2(this.firestore, null, new xt(t2));
  }
  withConverter(t2) {
    return new ac2(this.firestore, t2, this._path);
  }
};
function uc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), Hu("collection", "path", e), t2 instanceof sc2) {
    const s = _t.fromString(e, ...n);
    return Xu(s), new ac2(t2, null, s);
  }
  {
    if (!(t2 instanceof rc2 || t2 instanceof ac2))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return Xu(s), new ac2(t2.firestore, null, s);
  }
}
function cc2(t2, e) {
  if (t2 = tc2(t2, sc2), Hu("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new oc2(t2, null, function(t3) {
    return new ve(_t.emptyPath(), t3);
  }(e));
}
function hc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = it.R()), Hu("doc", "path", e), t2 instanceof sc2) {
    const s = _t.fromString(e, ...n);
    return Yu(s), new rc2(t2, null, new xt(s));
  }
  {
    if (!(t2 instanceof rc2 || t2 instanceof ac2))
      throw new Q2(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(_t.fromString(e, ...n));
    return Yu(s), new rc2(t2.firestore, t2 instanceof ac2 ? t2.converter : null, new xt(s));
  }
}
function lc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof rc2 || t2 instanceof ac2) && (e instanceof rc2 || e instanceof ac2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function fc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof oc2 && e instanceof oc2 && (t2.firestore === e.firestore && Be(t2._query, e._query) && t2.converter === e.converter);
}
var dc2 = class {
  constructor() {
    this.Du = Promise.resolve(), this.Cu = [], this.xu = false, this.Nu = [], this.ku = null, this.Mu = false, this.Ou = false, this.$u = [], this.vo = new $o(this, "async_queue_retry"), this.Fu = () => {
      const t3 = Mo();
      t3 && O2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.vo.To();
    };
    const t2 = Mo();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Fu);
  }
  get isShuttingDown() {
    return this.xu;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Bu(), this.Lu(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.xu) {
      this.xu = true, this.Ou = t2 || false;
      const e = Mo();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Fu);
    }
  }
  enqueue(t2) {
    if (this.Bu(), this.xu)
      return new Promise(() => {
      });
    const e = new j();
    return this.Lu(() => this.xu && this.Ou ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.Cu.push(t2), this.qu()));
  }
  async qu() {
    if (this.Cu.length !== 0) {
      try {
        await this.Cu[0](), this.Cu.shift(), this.vo.reset();
      } catch (t2) {
        if (!di(t2))
          throw t2;
        O2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.Cu.length > 0 && this.vo.po(() => this.qu());
    }
  }
  Lu(t2) {
    const e = this.Du.then(() => (this.Mu = true, t2().catch((t3) => {
      this.ku = t3, this.Mu = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw $("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Mu = false, t3))));
    return this.Du = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Bu(), this.$u.indexOf(t2) > -1 && (e = 0);
    const s = ya2.createAndSchedule(this, t2, e, n, (t3) => this.Uu(t3));
    return this.Nu.push(s), s;
  }
  Bu() {
    this.ku && L2();
  }
  verifyOperationInProgress() {
  }
  async Ku() {
    let t2;
    do {
      t2 = this.Du, await t2;
    } while (t2 !== this.Du);
  }
  Gu(t2) {
    for (const e of this.Nu)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Qu(t2) {
    return this.Ku().then(() => {
      this.Nu.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.Nu)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Ku();
    });
  }
  ju(t2) {
    this.$u.push(t2);
  }
  Uu(t2) {
    const e = this.Nu.indexOf(t2);
    this.Nu.splice(e, 1);
  }
};
function _c(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var wc2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var mc2 = -1;
var gc2 = class extends sc2 {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new dc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Tc2(this), this._firestoreClient.terminate();
  }
};
function yc2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new Q2(G.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new Q2(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function pc2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function Ic2(t2) {
  return t2._firestoreClient || Tc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Tc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new Vt(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new vu(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function Ec2(t2, e) {
  xc2(t2 = tc2(t2, gc2));
  const n = Ic2(t2), s = t2._freezeSettings(), i = new Eu();
  return Rc2(n, i, new Iu(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Ac2(t2) {
  xc2(t2 = tc2(t2, gc2));
  const e = Ic2(t2), n = t2._freezeSettings(), s = new Eu();
  return Rc2(e, s, new Tu(s, n.cacheSizeBytes));
}
function Rc2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Su(t2, n), await Du(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === G.FAILED_PRECONDITION || t4.code === G.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function bc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!hi.vt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await hi.delete(e2);
      }(Lr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Pc2(t2) {
  return function(t3) {
    const e = new j();
    return t3.asyncQueue.enqueueAndForget(async () => Ja2(await Ou(t3), e)), e.promise;
  }(Ic2(t2 = tc2(t2, gc2)));
}
function Vc2(t2) {
  return Fu(Ic2(t2 = tc2(t2, gc2)));
}
function vc2(t2) {
  return Bu(Ic2(t2 = tc2(t2, gc2)));
}
function Sc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Dc2(t2, e) {
  const n = Ic2(t2 = tc2(t2, gc2)), s = new wc2();
  return ju(n, t2._databaseId, e, s), s;
}
function Cc2(t2, e) {
  return Wu(Ic2(t2 = tc2(t2, gc2)), e).then((e2) => e2 ? new oc2(t2, null, e2.query) : null);
}
function xc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new Q2(G.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Nc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new mt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function kc2() {
  return new Nc2("__name__");
}
var Mc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Mc2(pt.fromBase64String(t2));
    } catch (t3) {
      throw new Q2(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Mc2(pt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Oc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var $c2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q2(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q2(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return rt(this._lat, t2._lat) || rt(this._long, t2._long);
  }
};
var Fc2 = /^__.*__$/;
var Bc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new pn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new yn(t2, this.data, e, this.fieldTransforms);
  }
};
var Lc2 = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new pn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function qc2(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var Uc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.M = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Wu(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get zu() {
    return this.settings.zu;
  }
  Hu(t2) {
    return new Uc2(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Ju(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Hu({
      path: n,
      Yu: false
    });
    return s.Xu(t2), s;
  }
  Zu(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Hu({
      path: n,
      Yu: false
    });
    return s.Wu(), s;
  }
  tc(t2) {
    return this.Hu({
      path: void 0,
      Yu: true
    });
  }
  ec(t2) {
    return uh(t2, this.settings.methodName, this.settings.nc || false, this.path, this.settings.sc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Wu() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.Xu(this.path.get(t2));
  }
  Xu(t2) {
    if (t2.length === 0)
      throw this.ec("Document fields must not be empty");
    if (qc2(this.zu) && Fc2.test(t2))
      throw this.ec('Document fields cannot begin and end with "__"');
  }
};
var Kc2 = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.M = n || Oo(t2);
  }
  ic(t2, e, n, s = false) {
    return new Uc2({
      zu: t2,
      methodName: e,
      sc: n,
      path: mt.emptyPath(),
      Yu: false,
      nc: s
    }, this.databaseId, this.M, this.ignoreUndefinedProperties);
  }
};
function Gc2(t2) {
  const e = t2._freezeSettings(), n = Oo(t2._databaseId);
  return new Kc2(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Qc2(t2, e, n, s, i, r = {}) {
  const o = t2.ic(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  ih("Data must be an object, but it was:", o, s);
  const a = nh(s, o);
  let u, c;
  if (r.merge)
    u = new gt(o.fieldMask), c = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = rh(e, s2, n);
      if (!o.contains(i2))
        throw new Q2(G.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      ch(t3, i2) || t3.push(i2);
    }
    u = new gt(t3), c = o.fieldTransforms.filter((t4) => u.covers(t4.field));
  } else
    u = null, c = o.fieldTransforms;
  return new Bc2(new Xt(a), u, c);
}
var jc2 = class extends Oc2 {
  _toFieldTransform(t2) {
    if (t2.zu !== 2)
      throw t2.zu === 1 ? t2.ec(`${this._methodName}() can only appear at the top level of your update data`) : t2.ec(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof jc2;
  }
};
function Wc2(t2, e, n) {
  return new Uc2({
    zu: 3,
    sc: e.settings.sc,
    methodName: t2._methodName,
    Yu: n
  }, e.databaseId, e.M, e.ignoreUndefinedProperties);
}
var zc2 = class extends Oc2 {
  _toFieldTransform(t2) {
    return new an(t2.path, new Xe());
  }
  isEqual(t2) {
    return t2 instanceof zc2;
  }
};
var Hc2 = class extends Oc2 {
  constructor(t2, e) {
    super(t2), this.rc = e;
  }
  _toFieldTransform(t2) {
    const e = Wc2(this, t2, true), n = this.rc.map((t3) => eh(t3, e)), s = new Ze(n);
    return new an(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var Jc2 = class extends Oc2 {
  constructor(t2, e) {
    super(t2), this.rc = e;
  }
  _toFieldTransform(t2) {
    const e = Wc2(this, t2, true), n = this.rc.map((t3) => eh(t3, e)), s = new en(n);
    return new an(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var Yc2 = class extends Oc2 {
  constructor(t2, e) {
    super(t2), this.oc = e;
  }
  _toFieldTransform(t2) {
    const e = new sn(t2.M, We(t2.M, this.oc));
    return new an(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function Xc2(t2, e, n, s) {
  const i = t2.ic(1, e, n);
  ih("Data must be an object, but it was:", i, s);
  const r = [], o = Xt.empty();
  lt(s, (t3, s2) => {
    const a2 = ah(e, t3, n);
    s2 = getModularInstance(s2);
    const u = i.Zu(a2);
    if (s2 instanceof jc2)
      r.push(a2);
    else {
      const t4 = eh(s2, u);
      t4 != null && (r.push(a2), o.set(a2, t4));
    }
  });
  const a = new gt(r);
  return new Lc2(o, a, i.fieldTransforms);
}
function Zc2(t2, e, n, s, i, r) {
  const o = t2.ic(1, e, n), a = [rh(e, s, n)], u = [i];
  if (r.length % 2 != 0)
    throw new Q2(G.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    a.push(rh(e, r[t3])), u.push(r[t3 + 1]);
  const c = [], h = Xt.empty();
  for (let t3 = a.length - 1; t3 >= 0; --t3)
    if (!ch(c, a[t3])) {
      const e2 = a[t3];
      let n2 = u[t3];
      n2 = getModularInstance(n2);
      const s2 = o.Zu(e2);
      if (n2 instanceof jc2)
        c.push(e2);
      else {
        const t4 = eh(n2, s2);
        t4 != null && (c.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new gt(c);
  return new Lc2(h, l2, o.fieldTransforms);
}
function th(t2, e, n, s = false) {
  return eh(n, t2.ic(s ? 4 : 3, e));
}
function eh(t2, e) {
  if (sh(t2 = getModularInstance(t2)))
    return ih("Unsupported field value:", e, t2), nh(t2, e);
  if (t2 instanceof Oc2)
    return function(t3, e2) {
      if (!qc2(e2.zu))
        throw e2.ec(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.ec(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.Yu && e.zu !== 4)
      throw e.ec("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = eh(i, e2.tc(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return We(e2.M, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = ut.fromDate(t3);
      return {
        timestampValue: rs(e2.M, n)
      };
    }
    if (t3 instanceof ut) {
      const n = new ut(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: rs(e2.M, n)
      };
    }
    if (t3 instanceof $c2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Mc2)
      return {
        bytesValue: os(e2.M, t3._byteString)
      };
    if (t3 instanceof rc2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.ec(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: cs(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.ec(`Unsupported field value: ${Zu(t3)}`);
  }(t2, e);
}
function nh(t2, e) {
  const n = {};
  return ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lt(t2, (t3, s) => {
    const i = eh(s, e.Ju(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function sh(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof ut || t2 instanceof $c2 || t2 instanceof Mc2 || t2 instanceof rc2 || t2 instanceof Oc2);
}
function ih(t2, e, n) {
  if (!sh(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = Zu(n);
    throw s === "an object" ? e.ec(t2 + " a custom object") : e.ec(t2 + " " + s);
  }
}
function rh(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Nc2)
    return e._internalPath;
  if (typeof e == "string")
    return ah(t2, e);
  throw uh("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var oh = new RegExp("[~\\*/\\[\\]]");
function ah(t2, e, n) {
  if (e.search(oh) >= 0)
    throw uh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Nc2(...e.split("."))._internalPath;
  } catch (s) {
    throw uh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function uh(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let u = "";
  return (r || o) && (u += " (found", r && (u += ` in field ${s}`), o && (u += ` in document ${i}`), u += ")"), new Q2(G.INVALID_ARGUMENT, a + t2 + u);
}
function ch(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var hh = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new rc2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new lh(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(fh("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var lh = class extends hh {
  data() {
    return super.data();
  }
};
function fh(t2, e) {
  return typeof e == "string" ? ah(t2, e) : e instanceof Nc2 ? e._internalPath : e._delegate._internalPath;
}
var dh = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var _h = class extends hh {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new wh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(fh("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var wh = class extends _h {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var mh = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new dh(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new wh(this._firestore, this._userDataWriter, n.key, n, new dh(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q2(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new wh(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new dh(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new wh(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new dh(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: gh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function gh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function yh(t2, e) {
  return t2 instanceof _h && e instanceof _h ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof mh && e instanceof mh && (t2._firestore === e._firestore && fc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function ph(t2) {
  if (xe(t2) && t2.explicitOrderBy.length === 0)
    throw new Q2(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Ih = class {
};
function Th(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Eh = class extends Ih {
  constructor(t2, e, n) {
    super(), this.ac = t2, this.uc = e, this.cc = n, this.type = "where";
  }
  _apply(t2) {
    const e = Gc2(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let a;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          $h(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Oh(s, t3, n3));
          a = {
            arrayValue: {
              values: e3
            }
          };
        } else
          a = Oh(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || $h(o, r), a = th(n2, e2, o, r === "in" || r === "not-in");
      const u = _e.create(i, r, a);
      return function(t4, e3) {
        if (e3.S()) {
          const n4 = ke(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = Ne(t4);
          s2 !== null && Fh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q2(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, u), u;
    }(t2._query, "where", e, t2.firestore._databaseId, this.ac, this.uc, this.cc);
    return new oc2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new ve(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Ah(t2, e, n) {
  const s = e, i = fh("where", t2);
  return new Eh(i, s, n);
}
var Rh = class extends Ih {
  constructor(t2, e) {
    super(), this.ac = t2, this.hc = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new Q2(G.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Re(e2, n);
      return function(t4, e3) {
        if (Ne(t4) === null) {
          const n2 = ke(t4);
          n2 !== null && Fh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.ac, this.hc);
    return new oc2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new ve(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function bh(t2, e = "asc") {
  const n = e, s = fh("orderBy", t2);
  return new Rh(s, n);
}
var Ph = class extends Ih {
  constructor(t2, e, n) {
    super(), this.type = t2, this.lc = e, this.fc = n;
  }
  _apply(t2) {
    return new oc2(t2.firestore, t2.converter, Fe(t2._query, this.lc, this.fc));
  }
};
function Vh(t2) {
  return ec2("limit", t2), new Ph("limit", t2, "F");
}
function vh(t2) {
  return ec2("limitToLast", t2), new Ph("limitToLast", t2, "L");
}
var Sh = class extends Ih {
  constructor(t2, e, n) {
    super(), this.type = t2, this.dc = e, this._c = n;
  }
  _apply(t2) {
    const e = Mh(t2, this.type, this.dc, this._c);
    return new oc2(t2.firestore, t2.converter, function(t3, e2) {
      return new ve(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Dh(...t2) {
  return new Sh("startAt", t2, true);
}
function Ch(...t2) {
  return new Sh("startAfter", t2, false);
}
var xh = class extends Ih {
  constructor(t2, e, n) {
    super(), this.type = t2, this.dc = e, this._c = n;
  }
  _apply(t2) {
    const e = Mh(t2, this.type, this.dc, this._c);
    return new oc2(t2.firestore, t2.converter, function(t3, e2) {
      return new ve(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Nh(...t2) {
  return new xh("endBefore", t2, false);
}
function kh(...t2) {
  return new xh("endAt", t2, true);
}
function Mh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof hh)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new Q2(G.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Oe(t3))
        if (n3.field.isKeyField())
          r.push(Ut(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Rt(t4))
            throw new Q2(G.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new Ae(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = Gc2(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q2(G.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const a = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const u = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof u != "string")
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof u}`);
          if (!Me(t3) && u.indexOf("/") !== -1)
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${u}' contains a slash.`);
          const n3 = t3.path.child(_t.fromString(u));
          if (!xt.isDocumentKey(n3))
            throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new xt(n3);
          a.push(Ut(e2, i3));
        } else {
          const t4 = th(n2, s2, u);
          a.push(t4);
        }
      }
      return new Ae(a, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Oh(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new Q2(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Me(e) && n.indexOf("/") !== -1)
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(_t.fromString(n));
    if (!xt.isDocumentKey(s))
      throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Ut(t2, new xt(s));
  }
  if (n instanceof rc2)
    return Ut(t2, n._key);
  throw new Q2(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Zu(n)}.`);
}
function $h(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q2(G.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function Fh(t2, e, n) {
  if (!n.isEqual(e))
    throw new Q2(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var Bh = class {
  convertValue(t2, e = "none") {
    switch (Mt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Et(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(At(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new $c2(Et(t2.latitude), Et(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = bt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Pt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Tt(t2);
    return new ut(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = _t.fromString(t2);
    q2(Os(n));
    const s = new vt(n.get(1), n.get(3)), i = new xt(n.popFirst(5));
    return s.isEqual(e) || $(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function Lh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var qh = class extends Bh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Mc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new rc2(this.firestore, null, e);
  }
};
var Uh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Gc2(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = Kh(t2, this._firestore), i = Lh(s.converter, e, n), r = Qc2(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, hn.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = Kh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Nc2 ? Zc2(this._dataReader, "WriteBatch.update", i._key, e, n, s) : Xc2(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, hn.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = Kh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new An(e._key, hn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q2(G.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function Kh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new Q2(G.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function Gh(t2) {
  t2 = tc2(t2, rc2);
  const e = tc2(t2.firestore, gc2);
  return qu(Ic2(e), t2._key).then((n) => il(e, t2, n));
}
var Qh = class extends Bh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Mc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new rc2(this.firestore, null, e);
  }
};
function jh(t2) {
  t2 = tc2(t2, rc2);
  const e = tc2(t2.firestore, gc2), n = Ic2(e), s = new Qh(e);
  return Lu(n, t2._key).then((n2) => new _h(e, s, t2._key, n2, new dh(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function Wh(t2) {
  t2 = tc2(t2, rc2);
  const e = tc2(t2.firestore, gc2);
  return qu(Ic2(e), t2._key, {
    source: "server"
  }).then((n) => il(e, t2, n));
}
function zh(t2) {
  t2 = tc2(t2, oc2);
  const e = tc2(t2.firestore, gc2), n = Ic2(e), s = new Qh(e);
  return ph(t2._query), Ku(n, t2._query).then((n2) => new mh(e, s, t2, n2));
}
function Hh(t2) {
  t2 = tc2(t2, oc2);
  const e = tc2(t2.firestore, gc2), n = Ic2(e), s = new Qh(e);
  return Uu(n, t2._query).then((n2) => new mh(e, s, t2, n2));
}
function Jh(t2) {
  t2 = tc2(t2, oc2);
  const e = tc2(t2.firestore, gc2), n = Ic2(e), s = new Qh(e);
  return Ku(n, t2._query, {
    source: "server"
  }).then((n2) => new mh(e, s, t2, n2));
}
function Yh(t2, e, n) {
  t2 = tc2(t2, rc2);
  const s = tc2(t2.firestore, gc2), i = Lh(t2.converter, e, n);
  return sl(s, [Qc2(Gc2(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, hn.none())]);
}
function Xh(t2, e, n, ...s) {
  t2 = tc2(t2, rc2);
  const i = tc2(t2.firestore, gc2), r = Gc2(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Nc2 ? Zc2(r, "updateDoc", t2._key, e, n, s) : Xc2(r, "updateDoc", t2._key, e);
  return sl(i, [o.toMutation(t2._key, hn.exists(true))]);
}
function Zh(t2) {
  return sl(tc2(t2.firestore, gc2), [new An(t2._key, hn.none())]);
}
function tl(t2, e) {
  const n = tc2(t2.firestore, gc2), s = hc2(t2), i = Lh(t2.converter, e);
  return sl(n, [Qc2(Gc2(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, hn.exists(false))]).then(() => s);
}
function el(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || _c(e[o]) || (r = e[o], o++);
  const a = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (_c(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let u, c, h;
  if (t2 instanceof rc2)
    c = tc2(t2.firestore, gc2), h = De(t2._key.path), u = {
      next: (n2) => {
        e[o] && e[o](il(c, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = tc2(t2, oc2);
    c = tc2(n2.firestore, gc2), h = n2._query;
    const s2 = new Qh(c);
    u = {
      next: (t3) => {
        e[o] && e[o](new mh(c, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, ph(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Ru(s2), r2 = new Da(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => ba2(await $u(t3), r2)), () => {
      i2.mu(), t3.asyncQueue.enqueueAndForget(async () => Pa(await $u(t3), r2));
    };
  }(Ic2(c), h, a, u);
}
function nl(t2, e) {
  return Gu(Ic2(t2 = tc2(t2, gc2)), _c(e) ? e : {
    next: e
  });
}
function sl(t2, e) {
  return function(t3, e2) {
    const n = new j();
    return t3.asyncQueue.enqueueAndForget(async () => Ga2(await Ou(t3), e2, n)), n.promise;
  }(Ic2(t2), e);
}
function il(t2, e, n) {
  const s = n.docs.get(e._key), i = new Qh(t2);
  return new _h(t2, i, e._key, s, new dh(n.hasPendingWrites, n.fromCache), e.converter);
}
var rl = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = Gc2(t2);
  }
  get(t2) {
    const e = Kh(t2, this._firestore), n = new qh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new hh(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new hh(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = Kh(t2, this._firestore), i = Lh(s.converter, e, n), r = Qc2(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = Kh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Nc2 ? Zc2(this._dataReader, "Transaction.update", i._key, e, n, s) : Xc2(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = Kh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = Kh(t2, this._firestore), n = new Qh(this._firestore);
    return super.get(t2).then((t3) => new _h(this._firestore, n, e._key, t3._document, new dh(false, false), e.converter));
  }
};
function ol(t2, e) {
  return Qu(Ic2(t2 = tc2(t2, gc2)), (n) => e(new rl(t2, n)));
}
function al() {
  return new jc2("deleteField");
}
function ul() {
  return new zc2("serverTimestamp");
}
function cl(...t2) {
  return new Hc2("arrayUnion", t2);
}
function hl(...t2) {
  return new Jc2("arrayRemove", t2);
}
function ll(t2) {
  return new Yc2("increment", t2);
}
function fl(t2) {
  return Ic2(t2 = tc2(t2, gc2)), new Uh(t2, (e) => sl(t2, e));
}
function dl(t2, e) {
  Ic2(t2 = tc2(t2, gc2));
  const n = typeof e == "string" ? function(t3) {
    try {
      return JSON.parse(t3);
    } catch (t4) {
      throw new Q2(G.INVALID_ARGUMENT, "Failed to parse JSON:" + t4.message);
    }
  }(e) : e, s = [];
  if (Array.isArray(n.indexes))
    for (const t3 of n.indexes) {
      const e2 = _l(t3, "collectionGroup"), n2 = [];
      if (Array.isArray(t3.fields))
        for (const e3 of t3.fields) {
          const t4 = ah("setIndexConfiguration", _l(e3, "fieldPath"));
          e3.arrayConfig === "CONTAINS" ? n2.push(new ie(t4, 2)) : e3.order === "ASCENDING" ? n2.push(new ie(t4, 0)) : e3.order === "DESCENDING" && n2.push(new ie(t4, 1));
        }
      s.push(new ee(ee.UNKNOWN_ID, e2, n2, re.empty()));
    }
  return Promise.resolve();
}
function _l(t2, e) {
  if (typeof t2[e] != "string")
    throw new Q2(G.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    x2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new gc2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.6", t2), registerVersion(D2, "3.4.6", "esm2017");
}();
export {
  Bh as AbstractUserDataWriter,
  Mc2 as Bytes,
  mc2 as CACHE_SIZE_UNLIMITED,
  ac2 as CollectionReference,
  rc2 as DocumentReference,
  _h as DocumentSnapshot,
  Nc2 as FieldPath,
  Oc2 as FieldValue,
  gc2 as Firestore,
  Q2 as FirestoreError,
  $c2 as GeoPoint,
  wc2 as LoadBundleTask,
  oc2 as Query,
  Ih as QueryConstraint,
  wh as QueryDocumentSnapshot,
  mh as QuerySnapshot,
  dh as SnapshotMetadata,
  ut as Timestamp,
  rl as Transaction,
  Uh as WriteBatch,
  vt as _DatabaseId,
  xt as _DocumentKey,
  et as _EmptyAppCheckTokenProvider,
  z2 as _EmptyAuthCredentialsProvider,
  mt as _FieldPath,
  tc2 as _cast,
  U2 as _debugAssert,
  yt as _isBase64Available,
  F2 as _logWarn,
  dl as _setIndexConfiguration,
  Ju as _validateIsNotUsedTogether,
  tl as addDoc,
  hl as arrayRemove,
  cl as arrayUnion,
  bc2 as clearIndexedDbPersistence,
  uc2 as collection,
  cc2 as collectionGroup,
  ic2 as connectFirestoreEmulator,
  Zh as deleteDoc,
  al as deleteField,
  vc2 as disableNetwork,
  hc2 as doc,
  kc2 as documentId,
  Ec2 as enableIndexedDbPersistence,
  Ac2 as enableMultiTabIndexedDbPersistence,
  Vc2 as enableNetwork,
  kh as endAt,
  Nh as endBefore,
  Ic2 as ensureFirestoreConfigured,
  sl as executeWrite,
  Gh as getDoc,
  jh as getDocFromCache,
  Wh as getDocFromServer,
  zh as getDocs,
  Hh as getDocsFromCache,
  Jh as getDocsFromServer,
  pc2 as getFirestore,
  ll as increment,
  yc2 as initializeFirestore,
  Vh as limit,
  vh as limitToLast,
  Dc2 as loadBundle,
  Cc2 as namedQuery,
  el as onSnapshot,
  nl as onSnapshotsInSync,
  bh as orderBy,
  Th as query,
  fc2 as queryEqual,
  lc2 as refEqual,
  ol as runTransaction,
  ul as serverTimestamp,
  Yh as setDoc,
  M2 as setLogLevel,
  yh as snapshotEqual,
  Ch as startAfter,
  Dh as startAt,
  Sc2 as terminate,
  Xh as updateDoc,
  Pc2 as waitForPendingWrites,
  Ah as where,
  fl as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
